/*
 * jPlayer Plugin for jQuery JavaScript Library
 * http://www.jplayer.org
 *
 * Copyright (c) 2009 - 2012 Happyworm Ltd
 * Dual licensed under the MIT and GPL licenses.
 *  - http://www.opensource.org/licenses/mit-license.php
 *  - http://www.gnu.org/copyleft/gpl.html
 *
 * Author: Mark J Panaghiston
 * Version: 2.2.16
 * Date: 21st November 2012
 */

/* Code verified using http://www.jshint.com/ */
/*jshint asi:false, bitwise:false, boss:false, browser:true, curly:true, debug:false, eqeqeq:true, eqnull:false, evil:false, forin:false, immed:false, jquery:true, laxbreak:false, newcap:true, noarg:true, noempty:true, nonew:true, onevar:false, passfail:false, plusplus:false, regexp:false, undef:true, sub:false, strict:false, white:false smarttabs:true */
/*global define:false, ActiveXObject:false, alert:false */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals
    factory(root.jQuery);
  }
}(this, function ($, undefined) {

  // Adapted from jquery.ui.widget.js (1.8.7): $.widget.bridge
  $.fn.jPlayer = function( options ) {
    var name = "jPlayer";
    var isMethodCall = typeof options === "string",
      args = Array.prototype.slice.call( arguments, 1 ),
      returnValue = this;

    // allow multiple hashes to be passed on init
    options = !isMethodCall && args.length ?
      $.extend.apply( null, [ true, options ].concat(args) ) :
      options;

    // prevent calls to internal methods
    if ( isMethodCall && options.charAt( 0 ) === "_" ) {
      return returnValue;
    }

    if ( isMethodCall ) {
      this.each(function() {
        var instance = $.data( this, name ),
          methodValue = instance && $.isFunction( instance[options] ) ?
            instance[ options ].apply( instance, args ) :
            instance;
        if ( methodValue !== instance && methodValue !== undefined ) {
          returnValue = methodValue;
          return false;
        }
      });
    } else {
      this.each(function() {
        var instance = $.data( this, name );
        if ( instance ) {
          // instance.option( options || {} )._init(); // Orig jquery.ui.widget.js code: Not recommend for jPlayer. ie., Applying new options to an existing instance (via the jPlayer constructor) and performing the _init(). The _init() is what concerns me. It would leave a lot of event handlers acting on jPlayer instance and the interface.
          instance.option( options || {} ); // The new constructor only changes the options. Changing options only has basic support atm.
        } else {
          $.data( this, name, new $.jPlayer( options, this ) );
        }
      });
    }

    return returnValue;
  };

  $.jPlayer = function( options, element ) {
    // allow instantiation without initializing for simple inheritance
    if ( arguments.length ) {
      this.element = $(element);
      this.options = $.extend(true, {},
        this.options,
        options
      );
      var self = this;
      this.element.bind( "remove.jPlayer", function() {
        self.destroy();
      });
      this._init();
    }
  };
  // End of: (Adapted from jquery.ui.widget.js (1.8.7))

  // Emulated HTML5 methods and properties
  $.jPlayer.emulateMethods = "load play pause";
  $.jPlayer.emulateStatus = "src readyState networkState currentTime duration paused ended playbackRate";
  $.jPlayer.emulateOptions = "muted volume";

  // Reserved event names generated by jPlayer that are not part of the HTML5 Media element spec
  $.jPlayer.reservedEvent = "ready flashreset resize repeat error warning";

  // Events generated by jPlayer
  $.jPlayer.event = {};
  $.each(
    [
      'ready',
      'flashreset', // Similar to the ready event if the Flash solution is set to display:none and then shown again or if it's reloaded for another reason by the browser. For example, using CSS position:fixed on Firefox for the full screen feature.
      'resize', // Occurs when the size changes through a full/restore screen operation or if the size/sizeFull options are changed.
      'repeat', // Occurs when the repeat status changes. Usually through clicks on the repeat button of the interface.
      'click', // Occurs when the user clicks on one of the following: poster image, html video, flash video.
      'error', // Event error code in event.jPlayer.error.type. See $.jPlayer.error
      'warning', // Event warning code in event.jPlayer.warning.type. See $.jPlayer.warning

      // Other events match HTML5 spec.
      'loadstart',
      'progress',
      'suspend',
      'abort',
      'emptied',
      'stalled',
      'play',
      'pause',
      'loadedmetadata',
      'loadeddata',
      'waiting',
      'playing',
      'canplay',
      'canplaythrough',
      'seeking',
      'seeked',
      'timeupdate',
      'ended',
      'ratechange',
      'durationchange',
      'volumechange'
    ],
    function() {
      $.jPlayer.event[ this ] = 'jPlayer_' + this;
    }
  );

  $.jPlayer.htmlEvent = [ // These HTML events are bubbled through to the jPlayer event, without any internal action.
    "loadstart",
    // "progress", // jPlayer uses internally before bubbling.
    // "suspend", // jPlayer uses internally before bubbling.
    "abort",
    // "error", // jPlayer uses internally before bubbling.
    "emptied",
    "stalled",
    // "play", // jPlayer uses internally before bubbling.
    // "pause", // jPlayer uses internally before bubbling.
    "loadedmetadata",
    "loadeddata",
    // "waiting", // jPlayer uses internally before bubbling.
    // "playing", // jPlayer uses internally before bubbling.
    "canplay",
    "canplaythrough",
    // "seeking", // jPlayer uses internally before bubbling.
    // "seeked", // jPlayer uses internally before bubbling.
    // "timeupdate", // jPlayer uses internally before bubbling.
    // "ended", // jPlayer uses internally before bubbling.
    "ratechange"
    // "durationchange" // jPlayer uses internally before bubbling.
    // "volumechange" // jPlayer uses internally before bubbling.
  ];

  $.jPlayer.pause = function() {
    $.each($.jPlayer.prototype.instances, function(i, element) {
      if(element.data("jPlayer").status.srcSet) { // Check that media is set otherwise would cause error event.
        element.jPlayer("pause");
      }
    });
  };

  // Default for jPlayer option.timeFormat
  $.jPlayer.timeFormat = {
    showHour: false,
    showMin: true,
    showSec: true,
    padHour: false,
    padMin: true,
    padSec: true,
    sepHour: ":",
    sepMin: ":",
    sepSec: ""
  };
  var ConvertTime = function() {
    this.init();
  };
  ConvertTime.prototype = {
    init: function() {
      this.options = {
        timeFormat: $.jPlayer.timeFormat
      };
    },
    time: function(s) { // function used on jPlayer.prototype._convertTime to enable per instance options.
      s = (s && typeof s === 'number') ? s : 0;

      var myTime = new Date(s * 1000),
        hour = myTime.getUTCHours(),
        min = this.options.timeFormat.showHour ? myTime.getUTCMinutes() : myTime.getUTCMinutes() + hour * 60,
        sec = this.options.timeFormat.showMin ? myTime.getUTCSeconds() : myTime.getUTCSeconds() + min * 60,
        strHour = (this.options.timeFormat.padHour && hour < 10) ? "0" + hour : hour,
        strMin = (this.options.timeFormat.padMin && min < 10) ? "0" + min : min,
        strSec = (this.options.timeFormat.padSec && sec < 10) ? "0" + sec : sec,
        strTime = "";

      strTime += this.options.timeFormat.showHour ? strHour + this.options.timeFormat.sepHour : "";
      strTime += this.options.timeFormat.showMin ? strMin + this.options.timeFormat.sepMin : "";
      strTime += this.options.timeFormat.showSec ? strSec + this.options.timeFormat.sepSec : "";

      return strTime;
    }
  };
  var myConvertTime = new ConvertTime();
  $.jPlayer.convertTime = function(s) {
    return myConvertTime.time(s);
  };

  // Adapting jQuery 1.4.4 code for jQuery.browser. Required since jQuery 1.3.2 does not detect Chrome as webkit.
  $.jPlayer.uaBrowser = function( userAgent ) {
    var ua = userAgent.toLowerCase();

    // Useragent RegExp
    var rwebkit = /(webkit)[ \/]([\w.]+)/;
    var ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/;
    var rmsie = /(msie) ([\w.]+)/;
    var rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/;

    var match = rwebkit.exec( ua ) ||
      ropera.exec( ua ) ||
      rmsie.exec( ua ) ||
      ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
      [];

    return { browser: match[1] || "", version: match[2] || "0" };
  };

  // Platform sniffer for detecting mobile devices
  $.jPlayer.uaPlatform = function( userAgent ) {
    var ua = userAgent.toLowerCase();

    // Useragent RegExp
    var rplatform = /(ipad|iphone|ipod|android|blackberry|playbook|windows ce|webos)/;
    var rtablet = /(ipad|playbook)/;
    var randroid = /(android)/;
    var rmobile = /(mobile)/;

    var platform = rplatform.exec( ua ) || [];
    var tablet = rtablet.exec( ua ) ||
      !rmobile.exec( ua ) && randroid.exec( ua ) ||
      [];

    if(platform[1]) {
      platform[1] = platform[1].replace(/\s/g, "_"); // Change whitespace to underscore. Enables dot notation.
    }

    return { platform: platform[1] || "", tablet: tablet[1] || "" };
  };

  $.jPlayer.browser = {
  };
  $.jPlayer.platform = {
  };

  var browserMatch = $.jPlayer.uaBrowser(navigator.userAgent);
  if ( browserMatch.browser ) {
    $.jPlayer.browser[ browserMatch.browser ] = true;
    $.jPlayer.browser.version = browserMatch.version;
  }
  var platformMatch = $.jPlayer.uaPlatform(navigator.userAgent);
  if ( platformMatch.platform ) {
    $.jPlayer.platform[ platformMatch.platform ] = true;
    $.jPlayer.platform.mobile = !platformMatch.tablet;
    $.jPlayer.platform.tablet = !!platformMatch.tablet;
  }

  // Internet Explorer (IE) Browser Document Mode Sniffer. Based on code at:
  // http://msdn.microsoft.com/en-us/library/cc288325%28v=vs.85%29.aspx#GetMode
  $.jPlayer.getDocMode = function() {
    var docMode;
    if ($.jPlayer.browser.msie) {
      if (document.documentMode) { // IE8 or later
        docMode = document.documentMode;
      } else { // IE 5-7
        docMode = 5; // Assume quirks mode unless proven otherwise
        if (document.compatMode) {
          if (document.compatMode === "CSS1Compat") {
            docMode = 7; // standards mode
          }
        }
      }
    }
    return docMode;
  };
  $.jPlayer.browser.documentMode = $.jPlayer.getDocMode();

  $.jPlayer.nativeFeatures = {
    init: function() {

      /* Fullscreen function naming influenced by W3C naming.
       * No support for: Mozilla Proposal: https://wiki.mozilla.org/Gecko:FullScreenAPI
       */

      var d = document,
        v = d.createElement('video'),
        spec = {
          // http://www.w3.org/TR/fullscreen/
          w3c: [
            'fullscreenEnabled',
            'fullscreenElement',
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenchange',
            'fullscreenerror'
          ],
          // https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode
          moz: [
            'mozFullScreenEnabled',
            'mozFullScreenElement',
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozfullscreenchange',
            'mozfullscreenerror'
          ],
          // http://developer.apple.com/library/safari/#documentation/WebKit/Reference/ElementClassRef/Element/Element.html
          // http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/DocumentAdditionsReference/DocumentAdditions/DocumentAdditions.html
          webkit: [
            '',
            'webkitCurrentFullScreenElement',
            'webkitRequestFullScreen',
            'webkitCancelFullScreen',
            'webkitfullscreenchange',
            ''
          ],
          // http://developer.apple.com/library/safari/#documentation/AudioVideo/Reference/HTMLVideoElementClassReference/HTMLVideoElement/HTMLVideoElement.html
          webkitVideo: [
            'webkitSupportsFullscreen',
            'webkitDisplayingFullscreen',
            'webkitEnterFullscreen',
            'webkitExitFullscreen',
            '',
            ''
          ]
        },
        specOrder = [
          'w3c',
          'moz',
          'webkit',
          'webkitVideo'
        ],
        fs, i, il;

      this.fullscreen = fs = {
        support: {
          w3c: !!d[spec.w3c[0]],
          moz: !!d[spec.moz[0]],
          webkit: typeof d[spec.webkit[3]] === 'function',
          webkitVideo: typeof v[spec.webkitVideo[2]] === 'function'
        },
        used: {}
      };

      // Store the name of the spec being used and as a handy boolean.
      for(i = 0, il = specOrder.length; i < il; i++) {
        var n = specOrder[i];
        if(fs.support[n]) {
          fs.spec = n;
          fs.used[n] = true;
          break;
        }
      }

      if(fs.spec) {
        var s = spec[fs.spec];
        fs.api = {
          fullscreenEnabled: true,
          fullscreenElement: function(elem) {
            elem = elem ? elem : d; // Video element required for webkitVideo
            return elem[s[1]];
          },
          requestFullscreen: function(elem) {
            return elem[s[2]]();
          },
          exitFullscreen: function(elem) {
            elem = elem ? elem : d; // Video element required for webkitVideo
            return elem[s[3]]();
          }
        };
        fs.event = {
          fullscreenchange: s[4],
          fullscreenerror: s[5]
        };
      } else {
        fs.api = {
          fullscreenEnabled: false,
          fullscreenElement: function() {
            return null;
          },
          requestFullscreen: function() {},
          exitFullscreen: function() {}
        };
        fs.event = {};
      }
    }
  };
  $.jPlayer.nativeFeatures.init();

  $.jPlayer.prototype = {
    count: 0, // Static Variable: Change it via prototype.
    version: { // Static Object
      script: "2.2.16",
      needFlash: "2.2.0",
      flash: "unknown"
    },
    options: { // Instanced in $.jPlayer() constructor
      swfPath: "js", // Path to Jplayer.swf. Can be relative, absolute or server root relative.
      solution: "html, flash", // Valid solutions: html, flash. Order defines priority. 1st is highest,
      supplied: "mp3", // Defines which formats jPlayer will try and support and the priority by the order. 1st is highest,
      preload: 'metadata',  // HTML5 Spec values: none, metadata, auto.
      volume: 0.8, // The volume. Number 0 to 1.
      muted: false,
      wmode: "opaque", // Valid wmode: window, transparent, opaque, direct, gpu. 
      backgroundColor: "#000000", // To define the jPlayer div and Flash background color.
      cssSelectorAncestor: "#jp_container_1",
      cssSelector: { // * denotes properties that should only be required when video media type required. _cssSelector() would require changes to enable splitting these into Audio and Video defaults.
        videoPlay: ".jp-video-play", // *
        play: ".jp-play",
        pause: ".jp-pause",
        stop: ".jp-stop",
        seekBar: ".jp-seek-bar",
        playBar: ".jp-play-bar",
        mute: ".jp-mute",
        unmute: ".jp-unmute",
        volumeBar: ".jp-volume-bar",
        volumeBarValue: ".jp-volume-bar-value",
        volumeMax: ".jp-volume-max",
        currentTime: ".jp-current-time",
        duration: ".jp-duration",
        fullScreen: ".jp-full-screen", // *
        restoreScreen: ".jp-restore-screen", // *
        repeat: ".jp-repeat",
        repeatOff: ".jp-repeat-off",
        gui: ".jp-gui", // The interface used with autohide feature.
        noSolution: ".jp-no-solution" // For error feedback when jPlayer cannot find a solution.
      },
      fullScreen: false, // Native Full Screen
      fullWindow: false,
      autohide: {
        restored: false, // Controls the interface autohide feature.
        full: true, // Controls the interface autohide feature.
        fadeIn: 200, // Milliseconds. The period of the fadeIn anim.
        fadeOut: 600, // Milliseconds. The period of the fadeOut anim.
        hold: 1000 // Milliseconds. The period of the pause before autohide beings.
      },
      loop: false,
      repeat: function(event) { // The default jPlayer repeat event handler
        if(event.jPlayer.options.loop) {
          $(this).unbind(".jPlayerRepeat").bind($.jPlayer.event.ended + ".jPlayer.jPlayerRepeat", function() {
            $(this).jPlayer("play");
          });
        } else {
          $(this).unbind(".jPlayerRepeat");
        }
      },
      nativeVideoControls: {
        // Works well on standard browsers.
        // Phone and tablet browsers can have problems with the controls disappearing.
      },
      noFullWindow: {
        msie: /msie [0-6]\./,
        ipad: /ipad.*?os [0-4]\./,
        iphone: /iphone/,
        ipod: /ipod/,
        android_pad: /android [0-3]\.(?!.*?mobile)/,
        android_phone: /android.*?mobile/,
        blackberry: /blackberry/,
        windows_ce: /windows ce/,
        iemobile: /iemobile/,
        webos: /webos/
      },
      noVolume: {
        ipad: /ipad/,
        iphone: /iphone/,
        ipod: /ipod/,
        android_pad: /android(?!.*?mobile)/,
        android_phone: /android.*?mobile/,
        blackberry: /blackberry/,
        windows_ce: /windows ce/,
        iemobile: /iemobile/,
        webos: /webos/,
        playbook: /playbook/
      },
      timeFormat: {
        // Specific time format for this instance. The supported options are defined in $.jPlayer.timeFormat
        // For the undefined options we use the default from $.jPlayer.timeFormat
      },
      verticalVolume: false, // Calculate volume from the bottom of the volume bar. Default is from the left. Also volume affects either width or height.
      // globalVolume: false, // Not implemented: Set to make volume changes affect all jPlayer instances
      // globalMute: false, // Not implemented: Set to make mute changes affect all jPlayer instances
      idPrefix: "jp", // Prefix for the ids of html elements created by jPlayer. For flash, this must not include characters: . - + * / \
      noConflict: "jQuery",
      emulateHtml: false, // Emulates the HTML5 Media element on the jPlayer element.
      errorAlerts: false,
      warningAlerts: false
    },
    optionsAudio: {
      size: {
        width: "0px",
        height: "0px",
        cssClass: ""
      },
      sizeFull: {
        width: "0px",
        height: "0px",
        cssClass: ""
      }
    },
    optionsVideo: {
      size: {
        width: "480px",
        height: "270px",
        cssClass: "jp-video-270p"
      },
      sizeFull: {
        width: "100%",
        height: "100%",
        cssClass: "jp-video-full"
      }
    },
    instances: {}, // Static Object
    status: { // Instanced in _init()
      src: "",
      media: {},
      paused: true,
      format: {},
      formatType: "",
      waitForPlay: true, // Same as waitForLoad except in case where preloading.
      waitForLoad: true,
      srcSet: false,
      video: false, // True if playing a video
      seekPercent: 0,
      currentPercentRelative: 0,
      currentPercentAbsolute: 0,
      currentTime: 0,
      duration: 0,
      readyState: 0,
      networkState: 0,
      playbackRate: 1,
      ended: 0

/*    Persistant status properties created dynamically at _init():
      width
      height
      cssClass
      nativeVideoControls
      noFullWindow
      noVolume
*/
    },

    internal: { // Instanced in _init()
      ready: false
      // instance: undefined
      // domNode: undefined
      // htmlDlyCmdId: undefined
      // autohideId: undefined
      // cmdsIgnored
    },
    solution: { // Static Object: Defines the solutions built in jPlayer.
      html: true,
      flash: true
    },
    // 'MPEG-4 support' : canPlayType('video/mp4; codecs="mp4v.20.8"')
    format: { // Static Object
      mp3: {
        codec: 'audio/mpeg; codecs="mp3"',
        flashCanPlay: true,
        media: 'audio'
      },
      m4a: { // AAC / MP4
        codec: 'audio/mp4; codecs="mp4a.40.2"',
        flashCanPlay: true,
        media: 'audio'
      },
      oga: { // OGG
        codec: 'audio/ogg; codecs="vorbis"',
        flashCanPlay: false,
        media: 'audio'
      },
      wav: { // PCM
        codec: 'audio/wav; codecs="1"',
        flashCanPlay: false,
        media: 'audio'
      },
      webma: { // WEBM
        codec: 'audio/webm; codecs="vorbis"',
        flashCanPlay: false,
        media: 'audio'
      },
      fla: { // FLV / F4A
        codec: 'audio/x-flv',
        flashCanPlay: true,
        media: 'audio'
      },
      rtmpa: { // RTMP AUDIO
        codec: 'audio/rtmp; codecs="rtmp"',
        flashCanPlay: true,
        media: 'audio'
      },
      m4v: { // H.264 / MP4
        codec: 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
        flashCanPlay: true,
        media: 'video'
      },
      ogv: { // OGG
        codec: 'video/ogg; codecs="theora, vorbis"',
        flashCanPlay: false,
        media: 'video'
      },
      webmv: { // WEBM
        codec: 'video/webm; codecs="vorbis, vp8"',
        flashCanPlay: false,
        media: 'video'
      },
      flv: { // FLV / F4V
        codec: 'video/x-flv',
        flashCanPlay: true,
        media: 'video'
      },
      rtmpv: { // RTMP VIDEO
        codec: 'video/rtmp; codecs="rtmp"',
        flashCanPlay: true,
        media: 'video'
      }
    },
    _init: function() {
      var self = this;

      this.element.empty();

      this.status = $.extend({}, this.status); // Copy static to unique instance.
      this.internal = $.extend({}, this.internal); // Copy static to unique instance.

      // Initialize the time format
      this.options.timeFormat = $.extend({}, $.jPlayer.timeFormat, this.options.timeFormat);

      // On iOS, assume commands will be ignored before user initiates them.
      this.internal.cmdsIgnored = $.jPlayer.platform.ipad || $.jPlayer.platform.iphone || $.jPlayer.platform.ipod;

      this.internal.domNode = this.element.get(0);

      this.formats = []; // Array based on supplied string option. Order defines priority.
      this.solutions = []; // Array based on solution string option. Order defines priority.
      this.require = {}; // Which media types are required: video, audio.

      this.htmlElement = {}; // DOM elements created by jPlayer
      this.html = {}; // In _init()'s this.desired code and setmedia(): Accessed via this[solution], where solution from this.solutions array.
      this.html.audio = {};
      this.html.video = {};
      this.flash = {}; // In _init()'s this.desired code and setmedia(): Accessed via this[solution], where solution from this.solutions array.

      this.css = {};
      this.css.cs = {}; // Holds the css selector strings
      this.css.jq = {}; // Holds jQuery selectors. ie., $(css.cs.method)

      this.ancestorJq = []; // Holds jQuery selector of cssSelectorAncestor. Init would use $() instead of [], but it is only 1.4+

      this.options.volume = this._limitValue(this.options.volume, 0, 1); // Limit volume value's bounds.

      // Create the formats array, with prority based on the order of the supplied formats string
      $.each(this.options.supplied.toLowerCase().split(","), function(index1, value1) {
        var format = value1.replace(/^\s+|\s+$/g, ""); //trim
        if(self.format[format]) { // Check format is valid.
          var dupFound = false;
          $.each(self.formats, function(index2, value2) { // Check for duplicates
            if(format === value2) {
              dupFound = true;
              return false;
            }
          });
          if(!dupFound) {
            self.formats.push(format);
          }
        }
      });

      // Create the solutions array, with prority based on the order of the solution string
      $.each(this.options.solution.toLowerCase().split(","), function(index1, value1) {
        var solution = value1.replace(/^\s+|\s+$/g, ""); //trim
        if(self.solution[solution]) { // Check solution is valid.
          var dupFound = false;
          $.each(self.solutions, function(index2, value2) { // Check for duplicates
            if(solution === value2) {
              dupFound = true;
              return false;
            }
          });
          if(!dupFound) {
            self.solutions.push(solution);
          }
        }
      });

      this.internal.instance = "jp_" + this.count;
      this.instances[this.internal.instance] = this.element;

      // Check the jPlayer div has an id and create one if required. Important for Flash to know the unique id for comms.
      if(!this.element.attr("id")) {
        this.element.attr("id", this.options.idPrefix + "_jplayer_" + this.count);
      }

      this.internal.self = $.extend({}, {
        id: this.element.attr("id"),
        jq: this.element
      });
      this.internal.audio = $.extend({}, {
        id: this.options.idPrefix + "_audio_" + this.count,
        jq: undefined
      });
      this.internal.video = $.extend({}, {
        id: this.options.idPrefix + "_video_" + this.count,
        jq: undefined
      });
      this.internal.flash = $.extend({}, {
        id: this.options.idPrefix + "_flash_" + this.count,
        jq: undefined,
        swf: this.options.swfPath + (this.options.swfPath.toLowerCase().slice(-4) !== ".swf" ? (this.options.swfPath && this.options.swfPath.slice(-1) !== "/" ? "/" : "") + "Jplayer.swf" : "")
      });
      this.internal.poster = $.extend({}, {
        id: this.options.idPrefix + "_poster_" + this.count,
        jq: undefined
      });

      // Register listeners defined in the constructor
      $.each($.jPlayer.event, function(eventName,eventType) {
        if(self.options[eventName] !== undefined) {
          self.element.bind(eventType + ".jPlayer", self.options[eventName]); // With .jPlayer namespace.
          self.options[eventName] = undefined; // Destroy the handler pointer copy on the options. Reason, events can be added/removed in other ways so this could be obsolete and misleading.
        }
      });

      // Determine if we require solutions for audio, video or both media types.
      this.require.audio = false;
      this.require.video = false;
      $.each(this.formats, function(priority, format) {
        self.require[self.format[format].media] = true;
      });

      // Now required types are known, finish the options default settings.
      if(this.require.video) {
        this.options = $.extend(true, {},
          this.optionsVideo,
          this.options
        );
      } else {
        this.options = $.extend(true, {},
          this.optionsAudio,
          this.options
        );
      }
      this._setSize(); // update status and jPlayer element size

      // Determine the status for Blocklisted options.
      this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls);
      this.status.noFullWindow = this._uaBlocklist(this.options.noFullWindow);
      this.status.noVolume = this._uaBlocklist(this.options.noVolume);

      // Create event handlers if native fullscreen is supported
      if($.jPlayer.nativeFeatures.fullscreen.api.fullscreenEnabled) {
        this._fullscreenAddEventListeners();
      }

      // The native controls are only for video and are disabled when audio is also used.
      this._restrictNativeVideoControls();

      // Create the poster image.
      this.htmlElement.poster = document.createElement('img');
      this.htmlElement.poster.id = this.internal.poster.id;
      this.htmlElement.poster.onload = function() { // Note that this did not work on Firefox 3.6: poster.addEventListener("onload", function() {}, false); Did not investigate x-browser.
        if(!self.status.video || self.status.waitForPlay) {
          self.internal.poster.jq.show();
        }
      };
      this.element.append(this.htmlElement.poster);
      this.internal.poster.jq = $("#" + this.internal.poster.id);
      this.internal.poster.jq.css({'width': this.status.width, 'height': this.status.height});
      this.internal.poster.jq.hide();
      this.internal.poster.jq.bind("click.jPlayer", function() {
        self._trigger($.jPlayer.event.click);
      });

      // Generate the required media elements
      this.html.audio.available = false;
      if(this.require.audio) { // If a supplied format is audio
        this.htmlElement.audio = document.createElement('audio');
        this.htmlElement.audio.id = this.internal.audio.id;
        this.html.audio.available = !!this.htmlElement.audio.canPlayType && this._testCanPlayType(this.htmlElement.audio); // Test is for IE9 on Win Server 2008.
      }
      this.html.video.available = false;
      if(this.require.video) { // If a supplied format is video
        this.htmlElement.video = document.createElement('video');
        this.htmlElement.video.id = this.internal.video.id;
        this.html.video.available = !!this.htmlElement.video.canPlayType && this._testCanPlayType(this.htmlElement.video); // Test is for IE9 on Win Server 2008.
      }

      this.flash.available = this._checkForFlash(10.1);

      this.html.canPlay = {};
      this.flash.canPlay = {};
      $.each(this.formats, function(priority, format) {
        self.html.canPlay[format] = self.html[self.format[format].media].available && "" !== self.htmlElement[self.format[format].media].canPlayType(self.format[format].codec);
        self.flash.canPlay[format] = self.format[format].flashCanPlay && self.flash.available;
      });
      this.html.desired = false;
      this.flash.desired = false;
      $.each(this.solutions, function(solutionPriority, solution) {
        if(solutionPriority === 0) {
          self[solution].desired = true;
        } else {
          var audioCanPlay = false;
          var videoCanPlay = false;
          $.each(self.formats, function(formatPriority, format) {
            if(self[self.solutions[0]].canPlay[format]) { // The other solution can play
              if(self.format[format].media === 'video') {
                videoCanPlay = true;
              } else {
                audioCanPlay = true;
              }
            }
          });
          self[solution].desired = (self.require.audio && !audioCanPlay) || (self.require.video && !videoCanPlay);
        }
      });
      // This is what jPlayer will support, based on solution and supplied.
      this.html.support = {};
      this.flash.support = {};
      $.each(this.formats, function(priority, format) {
        self.html.support[format] = self.html.canPlay[format] && self.html.desired;
        self.flash.support[format] = self.flash.canPlay[format] && self.flash.desired;
      });
      // If jPlayer is supporting any format in a solution, then the solution is used.
      this.html.used = false;
      this.flash.used = false;
      $.each(this.solutions, function(solutionPriority, solution) {
        $.each(self.formats, function(formatPriority, format) {
          if(self[solution].support[format]) {
            self[solution].used = true;
            return false;
          }
        });
      });

      // Init solution active state and the event gates to false.
      this._resetActive();
      this._resetGate();

      // Set up the css selectors for the control and feedback entities.
      this._cssSelectorAncestor(this.options.cssSelectorAncestor);

      // If neither html nor flash are being used by this browser, then media playback is not possible. Trigger an error event.
      if(!(this.html.used || this.flash.used)) {
        this._error( {
          type: $.jPlayer.error.NO_SOLUTION, 
          context: "{solution:'" + this.options.solution + "', supplied:'" + this.options.supplied + "'}",
          message: $.jPlayer.errorMsg.NO_SOLUTION,
          hint: $.jPlayer.errorHint.NO_SOLUTION
        });
        if(this.css.jq.noSolution.length) {
          this.css.jq.noSolution.show();
        }
      } else {
        if(this.css.jq.noSolution.length) {
          this.css.jq.noSolution.hide();
        }
      }

      // Add the flash solution if it is being used.
      if(this.flash.used) {
        var htmlObj,
        flashVars = 'jQuery=' + encodeURI(this.options.noConflict) + '&id=' + encodeURI(this.internal.self.id) + '&vol=' + this.options.volume + '&muted=' + this.options.muted;

        // Code influenced by SWFObject 2.2: http://code.google.com/p/swfobject/
        // Non IE browsers have an initial Flash size of 1 by 1 otherwise the wmode affected the Flash ready event. 

        if($.jPlayer.browser.msie && (Number($.jPlayer.browser.version) < 9 || $.jPlayer.browser.documentMode < 9)) {
          var objStr = '<object id="' + this.internal.flash.id + '" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="0" height="0" tabindex="-1"></object>';

          var paramStr = [
            '<param name="movie" value="' + this.internal.flash.swf + '" />',
            '<param name="FlashVars" value="' + flashVars + '" />',
            '<param name="allowScriptAccess" value="always" />',
            '<param name="bgcolor" value="' + this.options.backgroundColor + '" />',
            '<param name="wmode" value="' + this.options.wmode + '" />'
          ];

          htmlObj = document.createElement(objStr);
          for(var i=0; i < paramStr.length; i++) {
            htmlObj.appendChild(document.createElement(paramStr[i]));
          }
        } else {
          var createParam = function(el, n, v) {
            var p = document.createElement("param");
            p.setAttribute("name", n);  
            p.setAttribute("value", v);
            el.appendChild(p);
          };

          htmlObj = document.createElement("object");
          htmlObj.setAttribute("id", this.internal.flash.id);
          htmlObj.setAttribute("data", this.internal.flash.swf);
          htmlObj.setAttribute("type", "application/x-shockwave-flash");
          htmlObj.setAttribute("width", "1"); // Non-zero
          htmlObj.setAttribute("height", "1"); // Non-zero
          htmlObj.setAttribute("tabindex", "-1");
          createParam(htmlObj, "flashvars", flashVars);
          createParam(htmlObj, "allowscriptaccess", "always");
          createParam(htmlObj, "bgcolor", this.options.backgroundColor);
          createParam(htmlObj, "wmode", this.options.wmode);
        }

        this.element.append(htmlObj);
        this.internal.flash.jq = $(htmlObj);
      }

      // Add the HTML solution if being used.
      if(this.html.used) {

        // The HTML Audio handlers
        if(this.html.audio.available) {
          this._addHtmlEventListeners(this.htmlElement.audio, this.html.audio);
          this.element.append(this.htmlElement.audio);
          this.internal.audio.jq = $("#" + this.internal.audio.id);
        }

        // The HTML Video handlers
        if(this.html.video.available) {
          this._addHtmlEventListeners(this.htmlElement.video, this.html.video);
          this.element.append(this.htmlElement.video);
          this.internal.video.jq = $("#" + this.internal.video.id);
          if(this.status.nativeVideoControls) {
            this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
          } else {
            this.internal.video.jq.css({'width':'0px', 'height':'0px'}); // Using size 0x0 since a .hide() causes issues in iOS
          }
          this.internal.video.jq.bind("click.jPlayer", function() {
            self._trigger($.jPlayer.event.click);
          });
        }
      }

      // Create the bridge that emulates the HTML Media element on the jPlayer DIV
      if( this.options.emulateHtml ) {
        this._emulateHtmlBridge();
      }

      if(this.html.used && !this.flash.used) { // If only HTML, then emulate flash ready() call after 100ms.
        setTimeout( function() {
          self.internal.ready = true;
          self.version.flash = "n/a";
          self._trigger($.jPlayer.event.repeat); // Trigger the repeat event so its handler can initialize itself with the loop option.
          self._trigger($.jPlayer.event.ready);
        }, 100);
      }

      // Initialize the interface components with the options.
      this._updateNativeVideoControls(); // Must do this first, otherwise there is a bizarre bug in iOS 4.3.2, where the native controls are not shown. Fails in iOS if called after _updateButtons() below. Works if called later in setMedia too, so it odd.
      this._updateInterface();
      this._updateButtons(false);
      this._updateAutohide();
      this._updateVolume(this.options.volume);
      this._updateMute(this.options.muted);
      if(this.css.jq.videoPlay.length) {
        this.css.jq.videoPlay.hide();
      }

      $.jPlayer.prototype.count++; // Change static variable via prototype.
    },
    destroy: function() {
      // MJP: The background change remains. Would need to store the original to restore it correctly.
      // MJP: The jPlayer element's size change remains.

      // Clear the media to reset the GUI and stop any downloads. Streams on some browsers had persited. (Chrome)
      this.clearMedia();
      // Remove the size/sizeFull cssClass from the cssSelectorAncestor
      this._removeUiClass();
      // Remove the times from the GUI
      if(this.css.jq.currentTime.length) {
        this.css.jq.currentTime.text("");
      }
      if(this.css.jq.duration.length) {
        this.css.jq.duration.text("");
      }
      // Remove any bindings from the interface controls.
      $.each(this.css.jq, function(fn, jq) {
        // Check selector is valid before trying to execute method.
        if(jq.length) {
          jq.unbind(".jPlayer");
        }
      });
      // Remove the click handlers for $.jPlayer.event.click
      this.internal.poster.jq.unbind(".jPlayer");
      if(this.internal.video.jq) {
        this.internal.video.jq.unbind(".jPlayer");
      }
      // Remove the fullscreen event handlers
      this._fullscreenRemoveEventListeners();
      // Destroy the HTML bridge.
      if(this.options.emulateHtml) {
        this._destroyHtmlBridge();
      }
      this.element.removeData("jPlayer"); // Remove jPlayer data
      this.element.unbind(".jPlayer"); // Remove all event handlers created by the jPlayer constructor
      this.element.empty(); // Remove the inserted child elements

      delete this.instances[this.internal.instance]; // Clear the instance on the static instance object
    },
    enable: function() { // Plan to implement
      // options.disabled = false
    },
    disable: function () { // Plan to implement
      // options.disabled = true
    },
    _testCanPlayType: function(elem) {
      // IE9 on Win Server 2008 did not implement canPlayType(), but it has the property.
      try {
        elem.canPlayType(this.format.mp3.codec); // The type is irrelevant.
        return true;
      } catch(err) {
        return false;
      }
    },
    _uaBlocklist: function(list) {
      // list : object with properties that are all regular expressions. Property names are irrelevant.
      // Returns true if the user agent is matched in list.
      var ua = navigator.userAgent.toLowerCase(),
        block = false;

      $.each(list, function(p, re) {
        if(re && re.test(ua)) {
          block = true;
          return false; // exit $.each.
        }
      });
      return block;
    },
    _restrictNativeVideoControls: function() {
      // Fallback to noFullWindow when nativeVideoControls is true and audio media is being used. Affects when both media types are used.
      if(this.require.audio) {
        if(this.status.nativeVideoControls) {
          this.status.nativeVideoControls = false;
          this.status.noFullWindow = true;
        }
      }
    },
    _updateNativeVideoControls: function() {
      if(this.html.video.available && this.html.used) {
        // Turn the HTML Video controls on/off
        this.htmlElement.video.controls = this.status.nativeVideoControls;
        // Show/hide the jPlayer GUI.
        this._updateAutohide();
        // For when option changed. The poster image is not updated, as it is dealt with in setMedia(). Acceptable degradation since seriously doubt these options will change on the fly. Can again review later.
        if(this.status.nativeVideoControls && this.require.video) {
          this.internal.poster.jq.hide();
          this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
        } else if(this.status.waitForPlay && this.status.video) {
          this.internal.poster.jq.show();
          this.internal.video.jq.css({'width': '0px', 'height': '0px'});
        }
      }
    },
    _addHtmlEventListeners: function(mediaElement, entity) {
      var self = this;
      mediaElement.preload = this.options.preload;
      mediaElement.muted = this.options.muted;
      mediaElement.volume = this.options.volume;

      // Create the event listeners
      // Only want the active entity to affect jPlayer and bubble events.
      // Using entity.gate so that object is referenced and gate property always current

      mediaElement.addEventListener("progress", function() {
        if(entity.gate) {
          if(self.internal.cmdsIgnored && this.readyState > 0) { // Detect iOS executed the command
            self.internal.cmdsIgnored = false;
          }
          self._getHtmlStatus(mediaElement);
          self._updateInterface();
          self._trigger($.jPlayer.event.progress);
        }
      }, false);
      mediaElement.addEventListener("timeupdate", function() {
        if(entity.gate) {
          self._getHtmlStatus(mediaElement);
          self._updateInterface();
          self._trigger($.jPlayer.event.timeupdate);
        }
      }, false);
      mediaElement.addEventListener("durationchange", function() {
        if(entity.gate) {
          self._getHtmlStatus(mediaElement);
          self._updateInterface();
          self._trigger($.jPlayer.event.durationchange);
        }
      }, false);
      mediaElement.addEventListener("play", function() {
        if(entity.gate) {
          self._updateButtons(true);
          self._html_checkWaitForPlay(); // So the native controls update this variable and puts the hidden interface in the correct state. Affects toggling native controls.
          self._trigger($.jPlayer.event.play);
        }
      }, false);
      mediaElement.addEventListener("playing", function() {
        if(entity.gate) {
          self._updateButtons(true);
          self._seeked();
          self._trigger($.jPlayer.event.playing);
        }
      }, false);
      mediaElement.addEventListener("pause", function() {
        if(entity.gate) {
          self._updateButtons(false);
          self._trigger($.jPlayer.event.pause);
        }
      }, false);
      mediaElement.addEventListener("waiting", function() {
        if(entity.gate) {
          self._seeking();
          self._trigger($.jPlayer.event.waiting);
        }
      }, false);
      mediaElement.addEventListener("seeking", function() {
        if(entity.gate) {
          self._seeking();
          self._trigger($.jPlayer.event.seeking);
        }
      }, false);
      mediaElement.addEventListener("seeked", function() {
        if(entity.gate) {
          self._seeked();
          self._trigger($.jPlayer.event.seeked);
        }
      }, false);
      mediaElement.addEventListener("volumechange", function() {
        if(entity.gate) {
          // Read the values back from the element as the Blackberry PlayBook shares the volume with the physical buttons master volume control.
          // However, when tested 6th July 2011, those buttons do not generate an event. The physical play/pause button does though.
          self.options.volume = mediaElement.volume;
          self.options.muted = mediaElement.muted;
          self._updateMute();
          self._updateVolume();
          self._trigger($.jPlayer.event.volumechange);
        }
      }, false);
      mediaElement.addEventListener("suspend", function() { // Seems to be the only way of capturing that the iOS4 browser did not actually play the media from the page code. ie., It needs a user gesture.
        if(entity.gate) {
          self._seeked();
          self._trigger($.jPlayer.event.suspend);
        }
      }, false);
      mediaElement.addEventListener("ended", function() {
        if(entity.gate) {
          // Order of the next few commands are important. Change the time and then pause.
          // Solves a bug in Firefox, where issuing pause 1st causes the media to play from the start. ie., The pause is ignored.
          if(!$.jPlayer.browser.webkit) { // Chrome crashes if you do this in conjunction with a setMedia command in an ended event handler. ie., The playlist demo.
            self.htmlElement.media.currentTime = 0; // Safari does not care about this command. ie., It works with or without this line. (Both Safari and Chrome are Webkit.)
          }
          self.htmlElement.media.pause(); // Pause otherwise a click on the progress bar will play from that point, when it shouldn't, since it stopped playback.
          self._updateButtons(false);
          self._getHtmlStatus(mediaElement, true); // With override true. Otherwise Chrome leaves progress at full.
          self._updateInterface();
          self._trigger($.jPlayer.event.ended);
        }
      }, false);
      mediaElement.addEventListener("error", function() {
        if(entity.gate) {
          self._updateButtons(false);
          self._seeked();
          if(self.status.srcSet) { // Deals with case of clearMedia() causing an error event.
            clearTimeout(self.internal.htmlDlyCmdId); // Clears any delayed commands used in the HTML solution.
            self.status.waitForLoad = true; // Allows the load operation to try again.
            self.status.waitForPlay = true; // Reset since a play was captured.
            if(self.status.video && !self.status.nativeVideoControls) {
              self.internal.video.jq.css({'width':'0px', 'height':'0px'});
            }
            if(self._validString(self.status.media.poster) && !self.status.nativeVideoControls) {
              self.internal.poster.jq.show();
            }
            if(self.css.jq.videoPlay.length) {
              self.css.jq.videoPlay.show();
            }
            self._error( {
              type: $.jPlayer.error.URL,
              context: self.status.src, // this.src shows absolute urls. Want context to show the url given.
              message: $.jPlayer.errorMsg.URL,
              hint: $.jPlayer.errorHint.URL
            });
          }
        }
      }, false);
      // Create all the other event listeners that bubble up to a jPlayer event from html, without being used by jPlayer.
      $.each($.jPlayer.htmlEvent, function(i, eventType) {
        mediaElement.addEventListener(this, function() {
          if(entity.gate) {
            self._trigger($.jPlayer.event[eventType]);
          }
        }, false);
      });
    },
    _getHtmlStatus: function(media, override) {
      var ct = 0, cpa = 0, sp = 0, cpr = 0;

      // Fixes the duration bug in iOS, where the durationchange event occurs when media.duration is not always correct.
      // Fixes the initial duration bug in BB OS7, where the media.duration is infinity and displays as NaN:NaN due to Date() using inifity.
      if(isFinite(media.duration)) {
        this.status.duration = media.duration;
      }

      ct = media.currentTime;
      cpa = (this.status.duration > 0) ? 100 * ct / this.status.duration : 0;
      if((typeof media.seekable === "object") && (media.seekable.length > 0)) {
        sp = (this.status.duration > 0) ? 100 * media.seekable.end(media.seekable.length-1) / this.status.duration : 100;
        cpr = (this.status.duration > 0) ? 100 * media.currentTime / media.seekable.end(media.seekable.length-1) : 0; // Duration conditional for iOS duration bug. ie., seekable.end is a NaN in that case.
      } else {
        sp = 100;
        cpr = cpa;
      }

      if(override) {
        ct = 0;
        cpr = 0;
        cpa = 0;
      }

      this.status.seekPercent = sp;
      this.status.currentPercentRelative = cpr;
      this.status.currentPercentAbsolute = cpa;
      this.status.currentTime = ct;

      this.status.readyState = media.readyState;
      this.status.networkState = media.networkState;
      this.status.playbackRate = media.playbackRate;
      this.status.ended = media.ended;
    },
    _resetStatus: function() {
      this.status = $.extend({}, this.status, $.jPlayer.prototype.status); // Maintains the status properties that persist through a reset.
    },
    _trigger: function(eventType, error, warning) { // eventType always valid as called using $.jPlayer.event.eventType
      var event = $.Event(eventType);
      event.jPlayer = {};
      event.jPlayer.version = $.extend({}, this.version);
      event.jPlayer.options = $.extend(true, {}, this.options); // Deep copy
      event.jPlayer.status = $.extend(true, {}, this.status); // Deep copy
      event.jPlayer.html = $.extend(true, {}, this.html); // Deep copy
      event.jPlayer.flash = $.extend(true, {}, this.flash); // Deep copy
      if(error) {
        event.jPlayer.error = $.extend({}, error);
      }
      if(warning) {
        event.jPlayer.warning = $.extend({}, warning);
      }
      this.element.trigger(event);
    },
    jPlayerFlashEvent: function(eventType, status) { // Called from Flash
      if(eventType === $.jPlayer.event.ready) {
        if(!this.internal.ready) {
          this.internal.ready = true;
          this.internal.flash.jq.css({'width':'0px', 'height':'0px'}); // Once Flash generates the ready event, minimise to zero as it is not affected by wmode anymore.

          this.version.flash = status.version;
          if(this.version.needFlash !== this.version.flash) {
            this._error( {
              type: $.jPlayer.error.VERSION,
              context: this.version.flash,
              message: $.jPlayer.errorMsg.VERSION + this.version.flash,
              hint: $.jPlayer.errorHint.VERSION
            });
          }
          this._trigger($.jPlayer.event.repeat); // Trigger the repeat event so its handler can initialize itself with the loop option.
          this._trigger(eventType);
        } else {
          // This condition occurs if the Flash is hidden and then shown again.
          // Firefox also reloads the Flash if the CSS position changes. position:fixed is used for full screen.

          // Only do this if the Flash is the solution being used at the moment. Affects Media players where both solution may be being used.
          if(this.flash.gate) {

            // Send the current status to the Flash now that it is ready (available) again.
            if(this.status.srcSet) {

              // Need to read original status before issuing the setMedia command.
              var currentTime = this.status.currentTime,
                paused = this.status.paused; 

              this.setMedia(this.status.media);
              if(currentTime > 0) {
                if(paused) {
                  this.pause(currentTime);
                } else {
                  this.play(currentTime);
                }
              }
            }
            this._trigger($.jPlayer.event.flashreset);
          }
        }
      }
      if(this.flash.gate) {
        switch(eventType) {
          case $.jPlayer.event.progress:
            this._getFlashStatus(status);
            this._updateInterface();
            this._trigger(eventType);
            break;
          case $.jPlayer.event.timeupdate:
            this._getFlashStatus(status);
            this._updateInterface();
            this._trigger(eventType);
            break;
          case $.jPlayer.event.play:
            this._seeked();
            this._updateButtons(true);
            this._trigger(eventType);
            break;
          case $.jPlayer.event.pause:
            this._updateButtons(false);
            this._trigger(eventType);
            break;
          case $.jPlayer.event.ended:
            this._updateButtons(false);
            this._trigger(eventType);
            break;
          case $.jPlayer.event.click:
            this._trigger(eventType); // This could be dealt with by the default
            break;
          case $.jPlayer.event.error:
            this.status.waitForLoad = true; // Allows the load operation to try again.
            this.status.waitForPlay = true; // Reset since a play was captured.
            if(this.status.video) {
              this.internal.flash.jq.css({'width':'0px', 'height':'0px'});
            }
            if(this._validString(this.status.media.poster)) {
              this.internal.poster.jq.show();
            }
            if(this.css.jq.videoPlay.length && this.status.video) {
              this.css.jq.videoPlay.show();
            }
            if(this.status.video) { // Set up for another try. Execute before error event.
              this._flash_setVideo(this.status.media);
            } else {
              this._flash_setAudio(this.status.media);
            }
            this._updateButtons(false);
            this._error( {
              type: $.jPlayer.error.URL,
              context:status.src,
              message: $.jPlayer.errorMsg.URL,
              hint: $.jPlayer.errorHint.URL
            });
            break;
          case $.jPlayer.event.seeking:
            this._seeking();
            this._trigger(eventType);
            break;
          case $.jPlayer.event.seeked:
            this._seeked();
            this._trigger(eventType);
            break;
          case $.jPlayer.event.ready:
            // The ready event is handled outside the switch statement.
            // Captured here otherwise 2 ready events would be generated if the ready event handler used setMedia.
            break;
          default:
            this._trigger(eventType);
        }
      }
      return false;
    },
    _getFlashStatus: function(status) {
      this.status.seekPercent = status.seekPercent;
      this.status.currentPercentRelative = status.currentPercentRelative;
      this.status.currentPercentAbsolute = status.currentPercentAbsolute;
      this.status.currentTime = status.currentTime;
      this.status.duration = status.duration;

      // The Flash does not generate this information in this release
      this.status.readyState = 4; // status.readyState;
      this.status.networkState = 0; // status.networkState;
      this.status.playbackRate = 1; // status.playbackRate;
      this.status.ended = false; // status.ended;
    },
    _updateButtons: function(playing) {
      if(playing !== undefined) {
        this.status.paused = !playing;
        if(this.css.jq.play.length && this.css.jq.pause.length) {
          if(playing) {
            this.css.jq.play.hide();
            this.css.jq.pause.show();
          } else {
            this.css.jq.play.show();
            this.css.jq.pause.hide();
          }
        }
      }
      if(this.css.jq.restoreScreen.length && this.css.jq.fullScreen.length) {
        if(this.status.noFullWindow) {
          this.css.jq.fullScreen.hide();
          this.css.jq.restoreScreen.hide();
        } else if(this.options.fullWindow) {
          this.css.jq.fullScreen.hide();
          this.css.jq.restoreScreen.show();
        } else {
          this.css.jq.fullScreen.show();
          this.css.jq.restoreScreen.hide();
        }
      }
      if(this.css.jq.repeat.length && this.css.jq.repeatOff.length) {
        if(this.options.loop) {
          this.css.jq.repeat.hide();
          this.css.jq.repeatOff.show();
        } else {
          this.css.jq.repeat.show();
          this.css.jq.repeatOff.hide();
        }
      }
    },
    _updateInterface: function() {
      if(this.css.jq.seekBar.length) {
        this.css.jq.seekBar.width(this.status.seekPercent+"%");
      }
      if(this.css.jq.playBar.length) {
        this.css.jq.playBar.width(this.status.currentPercentRelative+"%");
      }
      if(this.css.jq.currentTime.length) {
        this.css.jq.currentTime.text(this._convertTime(this.status.currentTime));
      }
      if(this.css.jq.duration.length) {
        this.css.jq.duration.text(this._convertTime(this.status.duration));
      }
    },
    _convertTime: ConvertTime.prototype.time,
    _seeking: function() {
      if(this.css.jq.seekBar.length) {
        this.css.jq.seekBar.addClass("jp-seeking-bg");
      }
    },
    _seeked: function() {
      if(this.css.jq.seekBar.length) {
        this.css.jq.seekBar.removeClass("jp-seeking-bg");
      }
    },
    _resetGate: function() {
      this.html.audio.gate = false;
      this.html.video.gate = false;
      this.flash.gate = false;
    },
    _resetActive: function() {
      this.html.active = false;
      this.flash.active = false;
    },
    setMedia: function(media) {

      /*  media[format] = String: URL of format. Must contain all of the supplied option's video or audio formats.
       *  media.poster = String: Video poster URL.
       *  media.subtitles = String: * NOT IMPLEMENTED * URL of subtitles SRT file
       *  media.chapters = String: * NOT IMPLEMENTED * URL of chapters SRT file
       *  media.stream = Boolean: * NOT IMPLEMENTED * Designating actual media streams. ie., "false/undefined" for files. Plan to refresh the flash every so often.
       */

      var self = this,
        supported = false,
        posterChanged = this.status.media.poster !== media.poster; // Compare before reset. Important for OSX Safari as this.htmlElement.poster.src is absolute, even if original poster URL was relative.

      this._resetMedia();
      this._resetGate();
      this._resetActive();

      $.each(this.formats, function(formatPriority, format) {
        var isVideo = self.format[format].media === 'video';
        $.each(self.solutions, function(solutionPriority, solution) {
          if(self[solution].support[format] && self._validString(media[format])) { // Format supported in solution and url given for format.
            var isHtml = solution === 'html';

            if(isVideo) {
              if(isHtml) {
                self.html.video.gate = true;
                self._html_setVideo(media);
                self.html.active = true;
              } else {
                self.flash.gate = true;
                self._flash_setVideo(media);
                self.flash.active = true;
              }
              if(self.css.jq.videoPlay.length) {
                self.css.jq.videoPlay.show();
              }
              self.status.video = true;
            } else {
              if(isHtml) {
                self.html.audio.gate = true;
                self._html_setAudio(media);
                self.html.active = true;
              } else {
                self.flash.gate = true;
                self._flash_setAudio(media);
                self.flash.active = true;
              }
              if(self.css.jq.videoPlay.length) {
                self.css.jq.videoPlay.hide();
              }
              self.status.video = false;
            }

            supported = true;
            return false; // Exit $.each
          }
        });
        if(supported) {
          return false; // Exit $.each
        }
      });

      if(supported) {
        if(!(this.status.nativeVideoControls && this.html.video.gate)) {
          // Set poster IMG if native video controls are not being used
          // Note: With IE the IMG onload event occurs immediately when cached.
          // Note: Poster hidden by default in _resetMedia()
          if(this._validString(media.poster)) {
            if(posterChanged) { // Since some browsers do not generate img onload event.
              this.htmlElement.poster.src = media.poster;
            } else {
              this.internal.poster.jq.show();
            }
          }
        }
        this.status.srcSet = true;
        this.status.media = $.extend({}, media);
        this._updateButtons(false);
        this._updateInterface();
      } else { // jPlayer cannot support any formats provided in this browser
        // Send an error event
        this._error( {
          type: $.jPlayer.error.NO_SUPPORT,
          context: "{supplied:'" + this.options.supplied + "'}",
          message: $.jPlayer.errorMsg.NO_SUPPORT,
          hint: $.jPlayer.errorHint.NO_SUPPORT
        });
      }
    },
    _resetMedia: function() {
      this._resetStatus();
      this._updateButtons(false);
      this._updateInterface();
      this._seeked();
      this.internal.poster.jq.hide();

      clearTimeout(this.internal.htmlDlyCmdId);

      if(this.html.active) {
        this._html_resetMedia();
      } else if(this.flash.active) {
        this._flash_resetMedia();
      }
    },
    clearMedia: function() {
      this._resetMedia();

      if(this.html.active) {
        this._html_clearMedia();
      } else if(this.flash.active) {
        this._flash_clearMedia();
      }

      this._resetGate();
      this._resetActive();
    },
    load: function() {
      if(this.status.srcSet) {
        if(this.html.active) {
          this._html_load();
        } else if(this.flash.active) {
          this._flash_load();
        }
      } else {
        this._urlNotSetError("load");
      }
    },
    play: function(time) {
      time = (typeof time === "number") ? time : NaN; // Remove jQuery event from click handler
      if(this.status.srcSet) {
        if(this.html.active) {
          this._html_play(time);
        } else if(this.flash.active) {
          this._flash_play(time);
        }
      } else {
        this._urlNotSetError("play");
      }
    },
    videoPlay: function() { // Handles clicks on the play button over the video poster
      this.play();
    },
    pause: function(time) {
      time = (typeof time === "number") ? time : NaN; // Remove jQuery event from click handler
      if(this.status.srcSet) {
        if(this.html.active) {
          this._html_pause(time);
        } else if(this.flash.active) {
          this._flash_pause(time);
        }
      } else {
        this._urlNotSetError("pause");
      }
    },
    pauseOthers: function() {
      var self = this;
      $.each(this.instances, function(i, element) {
        if(self.element !== element) { // Do not this instance.
          if(element.data("jPlayer").status.srcSet) { // Check that media is set otherwise would cause error event.
            element.jPlayer("pause");
          }
        }
      });
    },
    stop: function() {
      if(this.status.srcSet) {
        if(this.html.active) {
          this._html_pause(0);
        } else if(this.flash.active) {
          this._flash_pause(0);
        }
      } else {
        this._urlNotSetError("stop");
      }
    },
    playHead: function(p) {
      p = this._limitValue(p, 0, 100);
      if(this.status.srcSet) {
        if(this.html.active) {
          this._html_playHead(p);
        } else if(this.flash.active) {
          this._flash_playHead(p);
        }
      } else {
        this._urlNotSetError("playHead");
      }
    },
    _muted: function(muted) {
      this.options.muted = muted;
      if(this.html.used) {
        this._html_mute(muted);
      }
      if(this.flash.used) {
        this._flash_mute(muted);
      }

      // The HTML solution generates this event from the media element itself.
      if(!this.html.video.gate && !this.html.audio.gate) {
        this._updateMute(muted);
        this._updateVolume(this.options.volume);
        this._trigger($.jPlayer.event.volumechange);
      }
    },
    mute: function(mute) { // mute is either: undefined (true), an event object (true) or a boolean (muted).
      mute = mute === undefined ? true : !!mute;
      this._muted(mute);
    },
    unmute: function(unmute) { // unmute is either: undefined (true), an event object (true) or a boolean (!muted).
      unmute = unmute === undefined ? true : !!unmute;
      this._muted(!unmute);
    },
    _updateMute: function(mute) {
      if(mute === undefined) {
        mute = this.options.muted;
      }
      if(this.css.jq.mute.length && this.css.jq.unmute.length) {
        if(this.status.noVolume) {
          this.css.jq.mute.hide();
          this.css.jq.unmute.hide();
        } else if(mute) {
          this.css.jq.mute.hide();
          this.css.jq.unmute.show();
        } else {
          this.css.jq.mute.show();
          this.css.jq.unmute.hide();
        }
      }
    },
    volume: function(v) {
      v = this._limitValue(v, 0, 1);
      this.options.volume = v;

      if(this.html.used) {
        this._html_volume(v);
      }
      if(this.flash.used) {
        this._flash_volume(v);
      }

      // The HTML solution generates this event from the media element itself.
      if(!this.html.video.gate && !this.html.audio.gate) {
        this._updateVolume(v);
        this._trigger($.jPlayer.event.volumechange);
      }
    },
    volumeBar: function(e) { // Handles clicks on the volumeBar
      if(this.css.jq.volumeBar.length) {
        var offset = this.css.jq.volumeBar.offset(),
          x = e.pageX - offset.left,
          w = this.css.jq.volumeBar.width(),
          y = this.css.jq.volumeBar.height() - e.pageY + offset.top,
          h = this.css.jq.volumeBar.height();

        if(this.options.verticalVolume) {
          this.volume(y/h);
        } else {
          this.volume(x/w);
        }
      }
      if(this.options.muted) {
        this._muted(false);
      }
    },
    volumeBarValue: function(e) { // Handles clicks on the volumeBarValue
      this.volumeBar(e);
    },
    _updateVolume: function(v) {
      if(v === undefined) {
        v = this.options.volume;
      }
      v = this.options.muted ? 0 : v;

      if(this.status.noVolume) {
        if(this.css.jq.volumeBar.length) {
          this.css.jq.volumeBar.hide();
        }
        if(this.css.jq.volumeBarValue.length) {
          this.css.jq.volumeBarValue.hide();
        }
        if(this.css.jq.volumeMax.length) {
          this.css.jq.volumeMax.hide();
        }
      } else {
        if(this.css.jq.volumeBar.length) {
          this.css.jq.volumeBar.show();
        }
        if(this.css.jq.volumeBarValue.length) {
          this.css.jq.volumeBarValue.show();
          this.css.jq.volumeBarValue[this.options.verticalVolume ? "height" : "width"]((v*100)+"%");
        }
        if(this.css.jq.volumeMax.length) {
          this.css.jq.volumeMax.show();
        }
      }
    },
    volumeMax: function() { // Handles clicks on the volume max
      this.volume(1);
      if(this.options.muted) {
        this._muted(false);
      }
    },
    _cssSelectorAncestor: function(ancestor) {
      var self = this;
      this.options.cssSelectorAncestor = ancestor;
      this._removeUiClass();
      this.ancestorJq = ancestor ? $(ancestor) : []; // Would use $() instead of [], but it is only 1.4+
      if(ancestor && this.ancestorJq.length !== 1) { // So empty strings do not generate the warning.
        this._warning( {
          type: $.jPlayer.warning.CSS_SELECTOR_COUNT,
          context: ancestor,
          message: $.jPlayer.warningMsg.CSS_SELECTOR_COUNT + this.ancestorJq.length + " found for cssSelectorAncestor.",
          hint: $.jPlayer.warningHint.CSS_SELECTOR_COUNT
        });
      }
      this._addUiClass();
      $.each(this.options.cssSelector, function(fn, cssSel) {
        self._cssSelector(fn, cssSel);
      });
    },
    _cssSelector: function(fn, cssSel) {
      var self = this;
      if(typeof cssSel === 'string') {
        if($.jPlayer.prototype.options.cssSelector[fn]) {
          if(this.css.jq[fn] && this.css.jq[fn].length) {
            this.css.jq[fn].unbind(".jPlayer");
          }
          this.options.cssSelector[fn] = cssSel;
          this.css.cs[fn] = this.options.cssSelectorAncestor + " " + cssSel;

          if(cssSel) { // Checks for empty string
            this.css.jq[fn] = $(this.css.cs[fn]);
          } else {
            this.css.jq[fn] = []; // To comply with the css.jq[fn].length check before its use. As of jQuery 1.4 could have used $() for an empty set. 
          }

          if(this.css.jq[fn].length) {
            var handler = function(e) {
              self[fn](e);
              $(this).blur();
              return false;
            };
            this.css.jq[fn].bind("click.jPlayer", handler); // Using jPlayer namespace
          }

          if(cssSel && this.css.jq[fn].length !== 1) { // So empty strings do not generate the warning. ie., they just remove the old one.
            this._warning( {
              type: $.jPlayer.warning.CSS_SELECTOR_COUNT,
              context: this.css.cs[fn],
              message: $.jPlayer.warningMsg.CSS_SELECTOR_COUNT + this.css.jq[fn].length + " found for " + fn + " method.",
              hint: $.jPlayer.warningHint.CSS_SELECTOR_COUNT
            });
          }
        } else {
          this._warning( {
            type: $.jPlayer.warning.CSS_SELECTOR_METHOD,
            context: fn,
            message: $.jPlayer.warningMsg.CSS_SELECTOR_METHOD,
            hint: $.jPlayer.warningHint.CSS_SELECTOR_METHOD
          });
        }
      } else {
        this._warning( {
          type: $.jPlayer.warning.CSS_SELECTOR_STRING,
          context: cssSel,
          message: $.jPlayer.warningMsg.CSS_SELECTOR_STRING,
          hint: $.jPlayer.warningHint.CSS_SELECTOR_STRING
        });
      }
    },
    seekBar: function(e) { // Handles clicks on the seekBar
      if(this.css.jq.seekBar) {
        var offset = this.css.jq.seekBar.offset();
        var x = e.pageX - offset.left;
        var w = this.css.jq.seekBar.width();
        var p = 100*x/w;
        this.playHead(p);
      }
    },
    playBar: function(e) { // Handles clicks on the playBar
      this.seekBar(e);
    },
    repeat: function() { // Handle clicks on the repeat button
      this._loop(true);
    },
    repeatOff: function() { // Handle clicks on the repeatOff button
      this._loop(false);
    },
    _loop: function(loop) {
      if(this.options.loop !== loop) {
        this.options.loop = loop;
        this._updateButtons();
        this._trigger($.jPlayer.event.repeat);
      }
    },

    // Plan to review the cssSelector method to cope with missing associated functions accordingly.

    currentTime: function() { // Handles clicks on the text
      // Added to avoid errors using cssSelector system for the text
    },
    duration: function() { // Handles clicks on the text
      // Added to avoid errors using cssSelector system for the text
    },
    gui: function() { // Handles clicks on the gui
      // Added to avoid errors using cssSelector system for the gui
    },
    noSolution: function() { // Handles clicks on the error message
      // Added to avoid errors using cssSelector system for no-solution
    },

    // Options code adapted from ui.widget.js (1.8.7).  Made changes so the key can use dot notation. To match previous getData solution in jPlayer 1.
    option: function(key, value) {
      var options = key;

       // Enables use: options().  Returns a copy of options object
      if ( arguments.length === 0 ) {
        return $.extend( true, {}, this.options );
      }

      if(typeof key === "string") {
        var keys = key.split(".");

         // Enables use: options("someOption")  Returns a copy of the option. Supports dot notation.
        if(value === undefined) {

          var opt = $.extend(true, {}, this.options);
          for(var i = 0; i < keys.length; i++) {
            if(opt[keys[i]] !== undefined) {
              opt = opt[keys[i]];
            } else {
              this._warning( {
                type: $.jPlayer.warning.OPTION_KEY,
                context: key,
                message: $.jPlayer.warningMsg.OPTION_KEY,
                hint: $.jPlayer.warningHint.OPTION_KEY
              });
              return undefined;
            }
          }
          return opt;
        }

         // Enables use: options("someOptionObject", someObject}).  Creates: {someOptionObject:someObject}
         // Enables use: options("someOption", someValue).  Creates: {someOption:someValue}
         // Enables use: options("someOptionObject.someOption", someValue).  Creates: {someOptionObject:{someOption:someValue}}

        options = {};
        var opts = options;

        for(var j = 0; j < keys.length; j++) {
          if(j < keys.length - 1) {
            opts[keys[j]] = {};
            opts = opts[keys[j]];
          } else {
            opts[keys[j]] = value;
          }
        }
      }

       // Otherwise enables use: options(optionObject).  Uses original object (the key)

      this._setOptions(options);

      return this;
    },
    _setOptions: function(options) {
      var self = this;
      $.each(options, function(key, value) { // This supports the 2 level depth that the options of jPlayer has. Would review if we ever need more depth.
        self._setOption(key, value);
      });

      return this;
    },
    _setOption: function(key, value) {
      var self = this;

      // The ability to set options is limited at this time.

      switch(key) {
        case "volume" :
          this.volume(value);
          break;
        case "muted" :
          this._muted(value);
          break;
        case "cssSelectorAncestor" :
          this._cssSelectorAncestor(value); // Set and refresh all associations for the new ancestor.
          break;
        case "cssSelector" :
          $.each(value, function(fn, cssSel) {
            self._cssSelector(fn, cssSel); // NB: The option is set inside this function, after further validity checks.
          });
          break;
        case "fullScreen" :
          if(this.options[key] !== value) { // if changed
            var wkv = $.jPlayer.nativeFeatures.fullscreen.used.webkitVideo;
            if(!wkv || wkv && !this.status.waitForPlay) {
              if(!wkv) { // No sensible way to unset option on these devices.
                this.options[key] = value;
              }
              if(value) {
                this._requestFullscreen();
              } else {
                this._exitFullscreen();
              }
              if(!wkv) {
                this._setOption("fullWindow", value);
              }
            }
          }
          break;
        case "fullWindow" :
          if(this.options[key] !== value) { // if changed
            this._removeUiClass();
            this.options[key] = value;
            this._refreshSize();
          }
          break;
        case "size" :
          if(!this.options.fullWindow && this.options[key].cssClass !== value.cssClass) {
            this._removeUiClass();
          }
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this._refreshSize();
          break;
        case "sizeFull" :
          if(this.options.fullWindow && this.options[key].cssClass !== value.cssClass) {
            this._removeUiClass();
          }
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this._refreshSize();
          break;
        case "autohide" :
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this._updateAutohide();
          break;
        case "loop" :
          this._loop(value);
          break;
        case "nativeVideoControls" :
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls);
          this._restrictNativeVideoControls();
          this._updateNativeVideoControls();
          break;
        case "noFullWindow" :
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls); // Need to check again as noFullWindow can depend on this flag and the restrict() can override it.
          this.status.noFullWindow = this._uaBlocklist(this.options.noFullWindow);
          this._restrictNativeVideoControls();
          this._updateButtons();
          break;
        case "noVolume" :
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          this.status.noVolume = this._uaBlocklist(this.options.noVolume);
          this._updateVolume();
          this._updateMute();
          break;
        case "emulateHtml" :
          if(this.options[key] !== value) { // To avoid multiple event handlers being created, if true already.
            this.options[key] = value;
            if(value) {
              this._emulateHtmlBridge();
            } else {
              this._destroyHtmlBridge();
            }
          }
          break;
        case "timeFormat" :
          this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
          break;
      }

      return this;
    },
    // End of: (Options code adapted from ui.widget.js)

    _refreshSize: function() {
      this._setSize(); // update status and jPlayer element size
      this._addUiClass(); // update the ui class
      this._updateSize(); // update internal sizes
      this._updateButtons();
      this._updateAutohide();
      this._trigger($.jPlayer.event.resize);
    },
    _setSize: function() {
      // Determine the current size from the options
      if(this.options.fullWindow) {
        this.status.width = this.options.sizeFull.width;
        this.status.height = this.options.sizeFull.height;
        this.status.cssClass = this.options.sizeFull.cssClass;
      } else {
        this.status.width = this.options.size.width;
        this.status.height = this.options.size.height;
        this.status.cssClass = this.options.size.cssClass;
      }

      // Set the size of the jPlayer area.
      this.element.css({'width': this.status.width, 'height': this.status.height});
    },
    _addUiClass: function() {
      if(this.ancestorJq.length) {
        this.ancestorJq.addClass(this.status.cssClass);
      }
    },
    _removeUiClass: function() {
      if(this.ancestorJq.length) {
        this.ancestorJq.removeClass(this.status.cssClass);
      }
    },
    _updateSize: function() {
      // The poster uses show/hide so can simply resize it.
      this.internal.poster.jq.css({'width': this.status.width, 'height': this.status.height});

      // Video html or flash resized if necessary at this time, or if native video controls being used.
      if(!this.status.waitForPlay && this.html.active && this.status.video || this.html.video.available && this.html.used && this.status.nativeVideoControls) {
        this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
      }
      else if(!this.status.waitForPlay && this.flash.active && this.status.video) {
        this.internal.flash.jq.css({'width': this.status.width, 'height': this.status.height});
      }
    },
    _updateAutohide: function() {
      var self = this,
        event = "mousemove.jPlayer",
        namespace = ".jPlayerAutohide",
        eventType = event + namespace,
        handler = function() {
          self.css.jq.gui.fadeIn(self.options.autohide.fadeIn, function() {
            clearTimeout(self.internal.autohideId);
            self.internal.autohideId = setTimeout( function() {
              self.css.jq.gui.fadeOut(self.options.autohide.fadeOut);
            }, self.options.autohide.hold);
          });
        };

      if(this.css.jq.gui.length) {

        // End animations first so that its callback is executed now.
        // Otherwise an in progress fadeIn animation still has the callback to fadeOut again.
        this.css.jq.gui.stop(true, true);

        // Removes the fadeOut operation from the fadeIn callback.
        clearTimeout(this.internal.autohideId);

        this.element.unbind(namespace);
        this.css.jq.gui.unbind(namespace);

        if(!this.status.nativeVideoControls) {
          if(this.options.fullWindow && this.options.autohide.full || !this.options.fullWindow && this.options.autohide.restored) {
            this.element.bind(eventType, handler);
            this.css.jq.gui.bind(eventType, handler);
            this.css.jq.gui.hide();
          } else {
            this.css.jq.gui.show();
          }
        } else {
          this.css.jq.gui.hide();
        }
      }
    },
    fullScreen: function() {
      this._setOption("fullScreen", true);
    },
    restoreScreen: function() {
      this._setOption("fullScreen", false);
    },
    _fullscreenAddEventListeners: function() {
      var self = this,
        fs = $.jPlayer.nativeFeatures.fullscreen;

      if(fs.api.fullscreenEnabled) {
        if(fs.event.fullscreenchange) {
          // Create the event handler function and store it for removal.
          if(typeof this.internal.fullscreenchangeHandler !== 'function') {
            this.internal.fullscreenchangeHandler = function() {
              self._fullscreenchange();
            };
          }
          document.addEventListener(fs.event.fullscreenchange, this.internal.fullscreenchangeHandler, false);
        }
        // No point creating handler for fullscreenerror.
        // Either logic avoids fullscreen occurring (w3c/moz), or their is no event on the browser (webkit).
      }
    },
    _fullscreenRemoveEventListeners: function() {
      var fs = $.jPlayer.nativeFeatures.fullscreen;
      if(this.internal.fullscreenchangeHandler) {
        document.addEventListener(fs.event.fullscreenchange, this.internal.fullscreenchangeHandler, false);
      }
    },
    _fullscreenchange: function() {
      // If nothing is fullscreen, then we cannot be in fullscreen mode.
      if(this.options.fullScreen && !$.jPlayer.nativeFeatures.fullscreen.api.fullscreenElement()) {
        this._setOption("fullScreen", false);
      }
    },
    _requestFullscreen: function() {
      // Either the container or the jPlayer div
      var e = this.ancestorJq.length ? this.ancestorJq[0] : this.element[0],
        fs = $.jPlayer.nativeFeatures.fullscreen;

      // This method needs the video element. For iOS and Android.
      if(fs.used.webkitVideo) {
        e = this.htmlElement.video;
      }

      if(fs.api.fullscreenEnabled) {
        fs.api.requestFullscreen(e);
      }
    },
    _exitFullscreen: function() {

      var fs = $.jPlayer.nativeFeatures.fullscreen,
        e;

      // This method needs the video element. For iOS and Android.
      if(fs.used.webkitVideo) {
        e = this.htmlElement.video;
      }

      if(fs.api.fullscreenEnabled) {
        fs.api.exitFullscreen(e);
      }
    },
    _html_initMedia: function(media) {
      // Remove any existing track elements
      var $media = $(this.htmlElement.media).empty();

      // Create any track elements given with the media, as an Array of track Objects.
      $.each(media.track || [], function(i,v) {
        var track = document.createElement('track');
        track.setAttribute("kind", v.kind ? v.kind : "");
        track.setAttribute("src", v.src ? v.src : "");
        track.setAttribute("srclang", v.srclang ? v.srclang : "");
        track.setAttribute("label", v.label ? v.label : "");
        if(v.def) {
          track.setAttribute("default", v.def);
        }
        $media.append(track);
      });

      this.htmlElement.media.src = this.status.src;

      if(this.options.preload !== 'none') {
        this._html_load(); // See function for comments
      }
      this._trigger($.jPlayer.event.timeupdate); // The flash generates this event for its solution.
    },
    _html_setFormat: function(media) {
      var self = this;
      // Always finds a format due to checks in setMedia()
      $.each(this.formats, function(priority, format) {
        if(self.html.support[format] && media[format]) {
          self.status.src = media[format];
          self.status.format[format] = true;
          self.status.formatType = format;
          return false;
        }
      });
    },
    _html_setAudio: function(media) {
      this._html_setFormat(media);
      this.htmlElement.media = this.htmlElement.audio;
      this._html_initMedia(media);
    },
    _html_setVideo: function(media) {
      this._html_setFormat(media);
      if(this.status.nativeVideoControls) {
        this.htmlElement.video.poster = this._validString(media.poster) ? media.poster : "";
      }
      this.htmlElement.media = this.htmlElement.video;
      this._html_initMedia(media);
    },
    _html_resetMedia: function() {
      if(this.htmlElement.media) {
        if(this.htmlElement.media.id === this.internal.video.id && !this.status.nativeVideoControls) {
          this.internal.video.jq.css({'width':'0px', 'height':'0px'});
        }
        this.htmlElement.media.pause();
      }
    },
    _html_clearMedia: function() {
      if(this.htmlElement.media) {
        this.htmlElement.media.src = "about:blank";
        // The following load() is only required for Firefox 3.6 (PowerMacs).
        // Recent HTMl5 browsers only require the src change. Due to changes in W3C spec and load() effect.
        this.htmlElement.media.load(); // Stops an old, "in progress" download from continuing the download. Triggers the loadstart, error and emptied events, due to the empty src. Also an abort event if a download was in progress.
      }
    },
    _html_load: function() {
      // This function remains to allow the early HTML5 browsers to work, such as Firefox 3.6
      // A change in the W3C spec for the media.load() command means that this is no longer necessary.
      // This command should be removed and actually causes minor undesirable effects on some browsers. Such as loading the whole file and not only the metadata.
      if(this.status.waitForLoad) {
        this.status.waitForLoad = false;
        this.htmlElement.media.load();
      }
      clearTimeout(this.internal.htmlDlyCmdId);
    },
    _html_play: function(time) {
      var self = this,
        media = this.htmlElement.media;

      this._html_load(); // Loads if required and clears any delayed commands.

      if(!isNaN(time)) {

        // Attempt to play it, since iOS has been ignoring commands
        if(this.internal.cmdsIgnored) {
          media.play();
        }

        try {
          // !media.seekable is for old HTML5 browsers, like Firefox 3.6.
          // Checking seekable.length is important for iOS6 to work with setMedia().play(time)
          if(!media.seekable || typeof media.seekable === "object" && media.seekable.length > 0) {
            media.currentTime = time;
            media.play();
          } else {
            throw 1;
          }
        } catch(err) {
          this.internal.htmlDlyCmdId = setTimeout(function() {
            self.play(time);
          }, 250);
          return; // Cancel execution and wait for the delayed command.
        }
      } else {
        media.play();
      }
      this._html_checkWaitForPlay();
    },
    _html_pause: function(time) {
      var self = this,
        media = this.htmlElement.media;

      if(time > 0) { // We do not want the stop() command, which does pause(0), causing a load operation.
        this._html_load(); // Loads if required and clears any delayed commands.
      } else {
        clearTimeout(this.internal.htmlDlyCmdId);
      }

      // Order of these commands is important for Safari (Win) and IE9. Pause then change currentTime.
      media.pause();

      if(!isNaN(time)) {
        try {
          if(!media.seekable || typeof media.seekable === "object" && media.seekable.length > 0) {
            media.currentTime = time;
          } else {
            throw 1;
          }
        } catch(err) {
          this.internal.htmlDlyCmdId = setTimeout(function() {
            self.pause(time);
          }, 250);
          return; // Cancel execution and wait for the delayed command.
        }
      }
      if(time > 0) { // Avoids a setMedia() followed by stop() or pause(0) hiding the video play button.
        this._html_checkWaitForPlay();
      }
    },
    _html_playHead: function(percent) {
      var self = this,
        media = this.htmlElement.media;

      this._html_load(); // Loads if required and clears any delayed commands.

      try {
        if(typeof media.seekable === "object" && media.seekable.length > 0) {
          media.currentTime = percent * media.seekable.end(media.seekable.length-1) / 100;
        } else if(media.duration > 0 && !isNaN(media.duration)) {
          media.currentTime = percent * media.duration / 100;
        } else {
          throw "e";
        }
      } catch(err) {
        this.internal.htmlDlyCmdId = setTimeout(function() {
          self.playHead(percent);
        }, 250);
        return; // Cancel execution and wait for the delayed command.
      }
      if(!this.status.waitForLoad) {
        this._html_checkWaitForPlay();
      }
    },
    _html_checkWaitForPlay: function() {
      if(this.status.waitForPlay) {
        this.status.waitForPlay = false;
        if(this.css.jq.videoPlay.length) {
          this.css.jq.videoPlay.hide();
        }
        if(this.status.video) {
          this.internal.poster.jq.hide();
          this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
        }
      }
    },
    _html_volume: function(v) {
      if(this.html.audio.available) {
        this.htmlElement.audio.volume = v;
      }
      if(this.html.video.available) {
        this.htmlElement.video.volume = v;
      }
    },
    _html_mute: function(m) {
      if(this.html.audio.available) {
        this.htmlElement.audio.muted = m;
      }
      if(this.html.video.available) {
        this.htmlElement.video.muted = m;
      }
    },
    _flash_setAudio: function(media) {
      var self = this;
      try {
        // Always finds a format due to checks in setMedia()
        $.each(this.formats, function(priority, format) {
          if(self.flash.support[format] && media[format]) {
            switch (format) {
              case "m4a" :
              case "fla" :
                self._getMovie().fl_setAudio_m4a(media[format]);
                break;
              case "mp3" :
                self._getMovie().fl_setAudio_mp3(media[format]);
                break;
              case "rtmpa":
                self._getMovie().fl_setAudio_rtmp(media[format]);
                break;
            }
            self.status.src = media[format];
            self.status.format[format] = true;
            self.status.formatType = format;
            return false;
          }
        });

        if(this.options.preload === 'auto') {
          this._flash_load();
          this.status.waitForLoad = false;
        }
      } catch(err) { this._flashError(err); }
    },
    _flash_setVideo: function(media) {
      var self = this;
      try {
        // Always finds a format due to checks in setMedia()
        $.each(this.formats, function(priority, format) {
          if(self.flash.support[format] && media[format]) {
            switch (format) {
              case "m4v" :
              case "flv" :
                self._getMovie().fl_setVideo_m4v(media[format]);
                break;
              case "rtmpv":
                self._getMovie().fl_setVideo_rtmp(media[format]);
                break;    
            }
            self.status.src = media[format];
            self.status.format[format] = true;
            self.status.formatType = format;
            return false;
          }
        });

        if(this.options.preload === 'auto') {
          this._flash_load();
          this.status.waitForLoad = false;
        }
      } catch(err) { this._flashError(err); }
    },
    _flash_resetMedia: function() {
      this.internal.flash.jq.css({'width':'0px', 'height':'0px'}); // Must do via CSS as setting attr() to zero causes a jQuery error in IE.
      this._flash_pause(NaN);
    },
    _flash_clearMedia: function() {
      try {
        this._getMovie().fl_clearMedia();
      } catch(err) { this._flashError(err); }
    },
    _flash_load: function() {
      try {
        this._getMovie().fl_load();
      } catch(err) { this._flashError(err); }
      this.status.waitForLoad = false;
    },
    _flash_play: function(time) {
      try {
        this._getMovie().fl_play(time);
      } catch(err) { this._flashError(err); }
      this.status.waitForLoad = false;
      this._flash_checkWaitForPlay();
    },
    _flash_pause: function(time) {
      try {
        this._getMovie().fl_pause(time);
      } catch(err) { this._flashError(err); }
      if(time > 0) { // Avoids a setMedia() followed by stop() or pause(0) hiding the video play button.
        this.status.waitForLoad = false;
        this._flash_checkWaitForPlay();
      }
    },
    _flash_playHead: function(p) {
      try {
        this._getMovie().fl_play_head(p);
      } catch(err) { this._flashError(err); }
      if(!this.status.waitForLoad) {
        this._flash_checkWaitForPlay();
      }
    },
    _flash_checkWaitForPlay: function() {
      if(this.status.waitForPlay) {
        this.status.waitForPlay = false;
        if(this.css.jq.videoPlay.length) {
          this.css.jq.videoPlay.hide();
        }
        if(this.status.video) {
          this.internal.poster.jq.hide();
          this.internal.flash.jq.css({'width': this.status.width, 'height': this.status.height});
        }
      }
    },
    _flash_volume: function(v) {
      try {
        this._getMovie().fl_volume(v);
      } catch(err) { this._flashError(err); }
    },
    _flash_mute: function(m) {
      try {
        this._getMovie().fl_mute(m);
      } catch(err) { this._flashError(err); }
    },
    _getMovie: function() {
      return document[this.internal.flash.id];
    },
    _getFlashPluginVersion: function() {

      // _getFlashPluginVersion() code influenced by:
      // - FlashReplace 1.01: http://code.google.com/p/flashreplace/
      // - SWFObject 2.2: http://code.google.com/p/swfobject/

      var version = 0,
        flash;
      if(window.ActiveXObject) {
        try {
          flash = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
          if (flash) { // flash will return null when ActiveX is disabled
            var v = flash.GetVariable("$version");
            if(v) {
              v = v.split(" ")[1].split(",");
              version = parseInt(v[0], 10) + "." + parseInt(v[1], 10);
            }
          }
        } catch(e) {}
      }
      else if(navigator.plugins && navigator.mimeTypes.length > 0) {
        flash = navigator.plugins["Shockwave Flash"];
        if(flash) {
          version = navigator.plugins["Shockwave Flash"].description.replace(/.*\s(\d+\.\d+).*/, "$1");
        }
      }
      return version * 1; // Converts to a number
    },
    _checkForFlash: function (version) {
      var flashOk = false;
      if(this._getFlashPluginVersion() >= version) {
        flashOk = true;
      }
      return flashOk;
    },
    _validString: function(url) {
      return (url && typeof url === "string"); // Empty strings return false
    },
    _limitValue: function(value, min, max) {
      return (value < min) ? min : ((value > max) ? max : value);
    },
    _urlNotSetError: function(context) {
      this._error( {
        type: $.jPlayer.error.URL_NOT_SET,
        context: context,
        message: $.jPlayer.errorMsg.URL_NOT_SET,
        hint: $.jPlayer.errorHint.URL_NOT_SET
      });
    },
    _flashError: function(error) {
      var errorType;
      if(!this.internal.ready) {
        errorType = "FLASH";
      } else {
        errorType = "FLASH_DISABLED";
      }
      this._error( {
        type: $.jPlayer.error[errorType],
        context: this.internal.flash.swf,
        message: $.jPlayer.errorMsg[errorType] + error.message,
        hint: $.jPlayer.errorHint[errorType]
      });
      // Allow the audio player to recover if display:none and then shown again, or with position:fixed on Firefox.
      // This really only affects audio in a media player, as an audio player could easily move the jPlayer element away from such issues.
      this.internal.flash.jq.css({'width':'1px', 'height':'1px'});
    },
    _error: function(error) {
      this._trigger($.jPlayer.event.error, error);
      if(this.options.errorAlerts) {
        this._alert("Error!" + (error.message ? "\n\n" + error.message : "") + (error.hint ? "\n\n" + error.hint : "") + "\n\nContext: " + error.context);
      }
    },
    _warning: function(warning) {
      this._trigger($.jPlayer.event.warning, undefined, warning);
      if(this.options.warningAlerts) {
        this._alert("Warning!" + (warning.message ? "\n\n" + warning.message : "") + (warning.hint ? "\n\n" + warning.hint : "") + "\n\nContext: " + warning.context);
      }
    },
    _alert: function(message) {
      alert("jPlayer " + this.version.script + " : id='" + this.internal.self.id +"' : " + message);
    },
    _emulateHtmlBridge: function() {
      var self = this;

      // Emulate methods on jPlayer's DOM element.
      $.each( $.jPlayer.emulateMethods.split(/\s+/g), function(i, name) {
        self.internal.domNode[name] = function(arg) {
          self[name](arg);
        };

      });

      // Bubble jPlayer events to its DOM element.
      $.each($.jPlayer.event, function(eventName,eventType) {
        var nativeEvent = true;
        $.each( $.jPlayer.reservedEvent.split(/\s+/g), function(i, name) {
          if(name === eventName) {
            nativeEvent = false;
            return false;
          }
        });
        if(nativeEvent) {
          self.element.bind(eventType + ".jPlayer.jPlayerHtml", function() { // With .jPlayer & .jPlayerHtml namespaces.
            self._emulateHtmlUpdate();
            var domEvent = document.createEvent("Event");
            domEvent.initEvent(eventName, false, true);
            self.internal.domNode.dispatchEvent(domEvent);
          });
        }
        // The error event would require a special case
      });

      // IE9 has a readyState property on all elements. The document should have it, but all (except media) elements inherit it in IE9. This conflicts with Popcorn, which polls the readyState.
    },
    _emulateHtmlUpdate: function() {
      var self = this;

      $.each( $.jPlayer.emulateStatus.split(/\s+/g), function(i, name) {
        self.internal.domNode[name] = self.status[name];
      });
      $.each( $.jPlayer.emulateOptions.split(/\s+/g), function(i, name) {
        self.internal.domNode[name] = self.options[name];
      });
    },
    _destroyHtmlBridge: function() {
      var self = this;

      // Bridge event handlers are also removed by destroy() through .jPlayer namespace.
      this.element.unbind(".jPlayerHtml"); // Remove all event handlers created by the jPlayer bridge. So you can change the emulateHtml option.

      // Remove the methods and properties
      var emulated = $.jPlayer.emulateMethods + " " + $.jPlayer.emulateStatus + " " + $.jPlayer.emulateOptions;
      $.each( emulated.split(/\s+/g), function(i, name) {
        delete self.internal.domNode[name];
      });
    }
  };

  $.jPlayer.error = {
    FLASH: "e_flash",
    FLASH_DISABLED: "e_flash_disabled",
    NO_SOLUTION: "e_no_solution",
    NO_SUPPORT: "e_no_support",
    URL: "e_url",
    URL_NOT_SET: "e_url_not_set",
    VERSION: "e_version"
  };

  $.jPlayer.errorMsg = {
    FLASH: "jPlayer's Flash fallback is not configured correctly, or a command was issued before the jPlayer Ready event. Details: ", // Used in: _flashError()
    FLASH_DISABLED: "jPlayer's Flash fallback has been disabled by the browser due to the CSS rules you have used. Details: ", // Used in: _flashError()
    NO_SOLUTION: "No solution can be found by jPlayer in this browser. Neither HTML nor Flash can be used.", // Used in: _init()
    NO_SUPPORT: "It is not possible to play any media format provided in setMedia() on this browser using your current options.", // Used in: setMedia()
    URL: "Media URL could not be loaded.", // Used in: jPlayerFlashEvent() and _addHtmlEventListeners()
    URL_NOT_SET: "Attempt to issue media playback commands, while no media url is set.", // Used in: load(), play(), pause(), stop() and playHead()
    VERSION: "jPlayer " + $.jPlayer.prototype.version.script + " needs Jplayer.swf version " + $.jPlayer.prototype.version.needFlash + " but found " // Used in: jPlayerReady()
  };

  $.jPlayer.errorHint = {
    FLASH: "Check your swfPath option and that Jplayer.swf is there.",
    FLASH_DISABLED: "Check that you have not display:none; the jPlayer entity or any ancestor.",
    NO_SOLUTION: "Review the jPlayer options: support and supplied.",
    NO_SUPPORT: "Video or audio formats defined in the supplied option are missing.",
    URL: "Check media URL is valid.",
    URL_NOT_SET: "Use setMedia() to set the media URL.",
    VERSION: "Update jPlayer files."
  };

  $.jPlayer.warning = {
    CSS_SELECTOR_COUNT: "e_css_selector_count",
    CSS_SELECTOR_METHOD: "e_css_selector_method",
    CSS_SELECTOR_STRING: "e_css_selector_string",
    OPTION_KEY: "e_option_key"
  };

  $.jPlayer.warningMsg = {
    CSS_SELECTOR_COUNT: "The number of css selectors found did not equal one: ",
    CSS_SELECTOR_METHOD: "The methodName given in jPlayer('cssSelector') is not a valid jPlayer method.",
    CSS_SELECTOR_STRING: "The methodCssSelector given in jPlayer('cssSelector') is not a String or is empty.",
    OPTION_KEY: "The option requested in jPlayer('option') is undefined."
  };

  $.jPlayer.warningHint = {
    CSS_SELECTOR_COUNT: "Check your css selector and the ancestor.",
    CSS_SELECTOR_METHOD: "Check your method name.",
    CSS_SELECTOR_STRING: "Check your css selector is a string.",
    OPTION_KEY: "Check your option name."
  };
}));;/*! TinySort 1.4.29
* Copyright (c) 2008-2012 Ron Valstar http://www.sjeiti.com/
*
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*//*
* Description:
*   A jQuery plugin to sort child nodes by (sub) contents or attributes.
*
* Contributors:
* brian.gibson@gmail.com
* michael.thornberry@gmail.com
*
* Usage:
*   $("ul#people>li").tsort();
*   $("ul#people>li").tsort("span.surname");
*   $("ul#people>li").tsort("span.surname",{order:"desc"});
*   $("ul#people>li").tsort({place:"end"});
*
* Change default like so:
*   $.tinysort.defaults.order = "desc";
*
* in this update:
*   - added plugin hook
*   - stripped non-latin character ordering and turned it into a plugin
*
* in last update:
*   - header comment no longer stripped in minified version
* - revision number no longer corresponds to svn revision since it's now git
*
* Todos:
*   - todo: uppercase vs lowercase
*   - todo: 'foobar' != 'foobars' in non-latin
*
*/
;(function($) {
  // private vars
  var fls = !1              // minify placeholder
    ,nll = null             // minify placeholder
    ,prsflt = parseFloat        // minify placeholder
    ,mathmn = Math.min          // minify placeholder
    ,rxLastNr = /(-?\d+\.?\d*)$/g   // regex for testing strings ending on numbers
    ,aPluginPrepare = []
    ,aPluginSort = []
  ;
  //
  // init plugin
  $.tinysort = {
     id: 'TinySort'
    ,version: '1.4.29'
    ,copyright: 'Copyright (c) 2008-2012 Ron Valstar'
    ,uri: 'http://tinysort.sjeiti.com/'
    ,licensed: {
      MIT: 'http://www.opensource.org/licenses/mit-license.php'
      ,GPL: 'http://www.gnu.org/licenses/gpl.html'
    }
    ,plugin: function(prepare,sort){
      aPluginPrepare.push(prepare); // function(settings){doStuff();}
      aPluginSort.push(sort);     // function(valuesAreNumeric,sA,sB,iReturn){doStuff();return iReturn;}
    }
    ,defaults: { // default settings

       order: 'asc'     // order: asc, desc or rand

      ,attr: nll        // order by attribute value
      ,data: nll        // use the data attribute for sorting
      ,useVal: fls      // use element value instead of text

      ,place: 'start'     // place ordered elements at position: start, end, org (original position), first
      ,returns: fls     // return all elements or only the sorted ones (true/false)

      ,cases: fls       // a case sensitive sort orders [aB,aa,ab,bb]
      ,forceStrings:fls   // if false the string '2' will sort with the value 2, not the string '2'

      ,sortFunction: nll    // override the default sort function
    }
  };
  $.fn.extend({
    tinysort: function(_find,_settings) {
      if (_find&&typeof(_find)!='string') {
        _settings = _find;
        _find = nll;
      }

      var oSettings = $.extend({}, $.tinysort.defaults, _settings)
        ,sParent
        ,oThis = this
        ,iLen = $(this).length
        ,oElements = {} // contains sortable- and non-sortable list per parent
        ,bFind = !(!_find||_find=='')
        ,bAttr = !(oSettings.attr===nll||oSettings.attr=="")
        ,bData = oSettings.data!==nll
        // since jQuery's filter within each works on array index and not actual index we have to create the filter in advance
        ,bFilter = bFind&&_find[0]==':'
        ,$Filter = bFilter?oThis.filter(_find):oThis
        ,fnSort = oSettings.sortFunction
        ,iAsc = oSettings.order=='asc'?1:-1
        ,aNewOrder = []
      ;

      $.each(aPluginPrepare,function(i,fn){
        fn.call(fn,oSettings);
      });


      if (!fnSort) fnSort = oSettings.order=='rand'?function() {
        return Math.random()<.5?1:-1;
      }:function(a,b) {
        var bNumeric = fls
        // maybe toLower
          ,sA = !oSettings.cases?toLowerCase(a.s):a.s
          ,sB = !oSettings.cases?toLowerCase(b.s):b.s;
        // maybe force Strings
//        var bAString = typeof(sA)=='string';
//        var bBString = typeof(sB)=='string';
//        if (!oSettings.forceStrings&&(bAString||bBString)) {
//          if (!bAString) sA = ''+sA;
//          if (!bBString) sB = ''+sB;
        if (!oSettings.forceStrings) {
          // maybe mixed
          var  aAnum = sA&&sA.match(rxLastNr)
            ,aBnum = sB&&sB.match(rxLastNr);
          if (aAnum&&aBnum) {
            var  sAprv = sA.substr(0,sA.length-aAnum[0].length)
              ,sBprv = sB.substr(0,sB.length-aBnum[0].length);
            if (sAprv==sBprv) {
              bNumeric = !fls;
              sA = prsflt(aAnum[0]);
              sB = prsflt(aBnum[0]);
            }
          }
        }
        // return sort-integer
        var iReturn = iAsc*(sA<sB?-1:(sA>sB?1:0));

        $.each(aPluginSort,function(i,fn){
          iReturn = fn.call(fn,bNumeric,sA,sB,iReturn);
        });

        return iReturn;
      };

      oThis.each(function(i,el) {
        var $Elm = $(el)
          // element or sub selection
          ,mElmOrSub = bFind?(bFilter?$Filter.filter(el):$Elm.find(_find)):$Elm
          // text or attribute value
          ,sSort = bData?''+mElmOrSub.data(oSettings.data):(bAttr?mElmOrSub.attr(oSettings.attr):(oSettings.useVal?mElmOrSub.val():mElmOrSub.text()))
          // to sort or not to sort
          ,mParent = $Elm.parent();
        if (!oElements[mParent])  oElements[mParent] = {s:[],n:[]}; // s: sort, n: not sort
        if (mElmOrSub.length>0)   oElements[mParent].s.push({s:sSort,e:$Elm,n:i}); // s:string, e:element, n:number
        else            oElements[mParent].n.push({e:$Elm,n:i});
      });
      //
      // sort
      for (sParent in oElements) oElements[sParent].s.sort(fnSort);
      //
      // order elements and fill new order
      for (sParent in oElements) {
        var oParent = oElements[sParent]
          ,aOrg = [] // list for original position
          ,iLow = iLen
          ,aCnt = [0,0] // count how much we've sorted for retreival from either the sort list or the non-sort list (oParent.s/oParent.n)
          ,i;
        switch (oSettings.place) {
          case 'first': $.each(oParent.s,function(i,obj) { iLow = mathmn(iLow,obj.n) }); break;
          case 'org':   $.each(oParent.s,function(i,obj) { aOrg.push(obj.n) }); break;
          case 'end':   iLow = oParent.n.length; break;
          default:    iLow = 0;
        }
        for (i = 0;i<iLen;i++) {
          var bSList = contains(aOrg,i)?!fls:i>=iLow&&i<iLow+oParent.s.length
            ,mEl = (bSList?oParent.s:oParent.n)[aCnt[bSList?0:1]].e;
          mEl.parent().append(mEl);
          if (bSList||!oSettings.returns) aNewOrder.push(mEl.get(0));
          aCnt[bSList?0:1]++;
        }
      }
      oThis.length = 0;
      Array.prototype.push.apply(oThis,aNewOrder);
      return oThis;
    }
  });
  // toLowerCase
  function toLowerCase(s) {
    return s&&s.toLowerCase?s.toLowerCase():s;
  }
  // array contains
  function contains(a,n) {
    for (var i=0,l=a.length;i<l;i++) if (a[i]==n) return !fls;
    return fls;
  }
  // set functions
  $.fn.TinySort = $.fn.Tinysort = $.fn.tsort = $.fn.tinysort;
})(jQuery);

/*! Array.prototype.indexOf for IE (issue #26) */
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(elt /*, from*/) {
    var len = this.length
      ,from = Number(arguments[1])||0;
    from = from<0?Math.ceil(from):Math.floor(from);
    if (from<0) from += len;
    for (;from<len;from++){
      if (from in this && this[from]===elt) return from;
    }
    return -1;
  };
};(function(a,b){"use strict";var c=a.History=a.History||{};if(typeof c.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");c.Adapter={handlers:{},_uid:1,uid:function(a){return a._uid||(a._uid=c.Adapter._uid++)},bind:function(a,b,d){var e=c.Adapter.uid(a);c.Adapter.handlers[e]=c.Adapter.handlers[e]||{},c.Adapter.handlers[e][b]=c.Adapter.handlers[e][b]||[],c.Adapter.handlers[e][b].push(d),a["on"+b]=function(a,b){return function(d){c.Adapter.trigger(a,b,d)}}(a,b)},trigger:function(a,b,d){d=d||{};var e=c.Adapter.uid(a),f,g;c.Adapter.handlers[e]=c.Adapter.handlers[e]||{},c.Adapter.handlers[e][b]=c.Adapter.handlers[e][b]||[];for(f=0,g=c.Adapter.handlers[e][b].length;f<g;++f)c.Adapter.handlers[e][b][f].apply(this,[d])},extractEventData:function(a,c){var d=c&&c[a]||b;return d},onDomLoad:function(b){var c=a.setTimeout(function(){b()},2e3);a.onload=function(){clearTimeout(c),b()}}},typeof c.init!="undefined"&&c.init()})(window),function(a,b){"use strict";var c=a.console||b,d=a.document,e=a.navigator,f=a.sessionStorage||!1,g=a.setTimeout,h=a.clearTimeout,i=a.setInterval,j=a.clearInterval,k=a.JSON,l=a.alert,m=a.History=a.History||{},n=a.history;k.stringify=k.stringify||k.encode,k.parse=k.parse||k.decode;if(typeof m.init!="undefined")throw new Error("History.js Core has already been loaded...");m.init=function(){return typeof m.Adapter=="undefined"?!1:(typeof m.initCore!="undefined"&&m.initCore(),typeof m.initHtml4!="undefined"&&m.initHtml4(),!0)},m.initCore=function(){if(typeof m.initCore.initialized!="undefined")return!1;m.initCore.initialized=!0,m.options=m.options||{},m.options.hashChangeInterval=m.options.hashChangeInterval||100,m.options.safariPollInterval=m.options.safariPollInterval||500,m.options.doubleCheckInterval=m.options.doubleCheckInterval||500,m.options.storeInterval=m.options.storeInterval||1e3,m.options.busyDelay=m.options.busyDelay||250,m.options.debug=m.options.debug||!1,m.options.initialTitle=m.options.initialTitle||d.title,m.intervalList=[],m.clearAllIntervals=function(){var a,b=m.intervalList;if(typeof b!="undefined"&&b!==null){for(a=0;a<b.length;a++)j(b[a]);m.intervalList=null}},m.debug=function(){(m.options.debug||!1)&&m.log.apply(m,arguments)},m.log=function(){var a=typeof c!="undefined"&&typeof c.log!="undefined"&&typeof c.log.apply!="undefined",b=d.getElementById("log"),e,f,g,h,i;a?(h=Array.prototype.slice.call(arguments),e=h.shift(),typeof c.debug!="undefined"?c.debug.apply(c,[e,h]):c.log.apply(c,[e,h])):e="\n"+arguments[0]+"\n";for(f=1,g=arguments.length;f<g;++f){i=arguments[f];if(typeof i=="object"&&typeof k!="undefined")try{i=k.stringify(i)}catch(j){}e+="\n"+i+"\n"}return b?(b.value+=e+"\n-----\n",b.scrollTop=b.scrollHeight-b.clientHeight):a||l(e),!0},m.getInternetExplorerMajorVersion=function(){var a=m.getInternetExplorerMajorVersion.cached=typeof m.getInternetExplorerMajorVersion.cached!="undefined"?m.getInternetExplorerMajorVersion.cached:function(){var a=3,b=d.createElement("div"),c=b.getElementsByTagName("i");while((b.innerHTML="<!--[if gt IE "+ ++a+"]><i></i><![endif]-->")&&c[0]);return a>4?a:!1}();return a},m.isInternetExplorer=function(){var a=m.isInternetExplorer.cached=typeof m.isInternetExplorer.cached!="undefined"?m.isInternetExplorer.cached:Boolean(m.getInternetExplorerMajorVersion());return a},m.emulated={pushState:!Boolean(a.history&&a.history.pushState&&a.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(e.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(e.userAgent)),hashChange:Boolean(!("onhashchange"in a||"onhashchange"in d)||m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<8)},m.enabled=!m.emulated.pushState,m.bugs={setHash:Boolean(!m.emulated.pushState&&e.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(e.userAgent)),safariPoll:Boolean(!m.emulated.pushState&&e.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(e.userAgent)),ieDoubleCheck:Boolean(m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<7)},m.isEmptyObject=function(a){for(var b in a)return!1;return!0},m.cloneObject=function(a){var b,c;return a?(b=k.stringify(a),c=k.parse(b)):c={},c},m.getRootUrl=function(){var a=d.location.protocol+"//"+(d.location.hostname||d.location.host);if(d.location.port||!1)a+=":"+d.location.port;return a+="/",a},m.getBaseHref=function(){var a=d.getElementsByTagName("base"),b=null,c="";return a.length===1&&(b=a[0],c=b.href.replace(/[^\/]+$/,"")),c=c.replace(/\/+$/,""),c&&(c+="/"),c},m.getBaseUrl=function(){var a=m.getBaseHref()||m.getBasePageUrl()||m.getRootUrl();return a},m.getPageUrl=function(){var a=m.getState(!1,!1),b=(a||{}).url||d.location.href,c;return c=b.replace(/\/+$/,"").replace(/[^\/]+$/,function(a,b,c){return/\./.test(a)?a:a+"/"}),c},m.getBasePageUrl=function(){var a=d.location.href.replace(/[#\?].*/,"").replace(/[^\/]+$/,function(a,b,c){return/[^\/]$/.test(a)?"":a}).replace(/\/+$/,"")+"/";return a},m.getFullUrl=function(a,b){var c=a,d=a.substring(0,1);return b=typeof b=="undefined"?!0:b,/[a-z]+\:\/\//.test(a)||(d==="/"?c=m.getRootUrl()+a.replace(/^\/+/,""):d==="#"?c=m.getPageUrl().replace(/#.*/,"")+a:d==="?"?c=m.getPageUrl().replace(/[\?#].*/,"")+a:b?c=m.getBaseUrl()+a.replace(/^(\.\/)+/,""):c=m.getBasePageUrl()+a.replace(/^(\.\/)+/,"")),c.replace(/\#$/,"")},m.getShortUrl=function(a){var b=a,c=m.getBaseUrl(),d=m.getRootUrl();return m.emulated.pushState&&(b=b.replace(c,"")),b=b.replace(d,"/"),m.isTraditionalAnchor(b)&&(b="./"+b),b=b.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),b},m.store={},m.idToState=m.idToState||{},m.stateToId=m.stateToId||{},m.urlToId=m.urlToId||{},m.storedStates=m.storedStates||[],m.savedStates=m.savedStates||[],m.normalizeStore=function(){m.store.idToState=m.store.idToState||{},m.store.urlToId=m.store.urlToId||{},m.store.stateToId=m.store.stateToId||{}},m.getState=function(a,b){typeof a=="undefined"&&(a=!0),typeof b=="undefined"&&(b=!0);var c=m.getLastSavedState();return!c&&b&&(c=m.createStateObject()),a&&(c=m.cloneObject(c),c.url=c.cleanUrl||c.url),c},m.getIdByState=function(a){var b=m.extractId(a.url),c;if(!b){c=m.getStateString(a);if(typeof m.stateToId[c]!="undefined")b=m.stateToId[c];else if(typeof m.store.stateToId[c]!="undefined")b=m.store.stateToId[c];else{for(;;){b=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof m.idToState[b]=="undefined"&&typeof m.store.idToState[b]=="undefined")break}m.stateToId[c]=b,m.idToState[b]=a}}return b},m.normalizeState=function(a){var b,c;if(!a||typeof a!="object")a={};if(typeof a.normalized!="undefined")return a;if(!a.data||typeof a.data!="object")a.data={};b={},b.normalized=!0,b.title=a.title||"",b.url=m.getFullUrl(m.unescapeString(a.url||d.location.href)),b.hash=m.getShortUrl(b.url),b.data=m.cloneObject(a.data),b.id=m.getIdByState(b),b.cleanUrl=b.url.replace(/\??\&_suid.*/,""),b.url=b.cleanUrl,c=!m.isEmptyObject(b.data);if(b.title||c)b.hash=m.getShortUrl(b.url).replace(/\??\&_suid.*/,""),/\?/.test(b.hash)||(b.hash+="?"),b.hash+="&_suid="+b.id;return b.hashedUrl=m.getFullUrl(b.hash),(m.emulated.pushState||m.bugs.safariPoll)&&m.hasUrlDuplicate(b)&&(b.url=b.hashedUrl),b},m.createStateObject=function(a,b,c){var d={data:a,title:b,url:c};return d=m.normalizeState(d),d},m.getStateById=function(a){a=String(a);var c=m.idToState[a]||m.store.idToState[a]||b;return c},m.getStateString=function(a){var b,c,d;return b=m.normalizeState(a),c={data:b.data,title:a.title,url:a.url},d=k.stringify(c),d},m.getStateId=function(a){var b,c;return b=m.normalizeState(a),c=b.id,c},m.getHashByState=function(a){var b,c;return b=m.normalizeState(a),c=b.hash,c},m.extractId=function(a){var b,c,d;return c=/(.*)\&_suid=([0-9]+)$/.exec(a),d=c?c[1]||a:a,b=c?String(c[2]||""):"",b||!1},m.isTraditionalAnchor=function(a){var b=!/[\/\?\.]/.test(a);return b},m.extractState=function(a,b){var c=null,d,e;return b=b||!1,d=m.extractId(a),d&&(c=m.getStateById(d)),c||(e=m.getFullUrl(a),d=m.getIdByUrl(e)||!1,d&&(c=m.getStateById(d)),!c&&b&&!m.isTraditionalAnchor(a)&&(c=m.createStateObject(null,null,e))),c},m.getIdByUrl=function(a){var c=m.urlToId[a]||m.store.urlToId[a]||b;return c},m.getLastSavedState=function(){return m.savedStates[m.savedStates.length-1]||b},m.getLastStoredState=function(){return m.storedStates[m.storedStates.length-1]||b},m.hasUrlDuplicate=function(a){var b=!1,c;return c=m.extractState(a.url),b=c&&c.id!==a.id,b},m.storeState=function(a){return m.urlToId[a.url]=a.id,m.storedStates.push(m.cloneObject(a)),a},m.isLastSavedState=function(a){var b=!1,c,d,e;return m.savedStates.length&&(c=a.id,d=m.getLastSavedState(),e=d.id,b=c===e),b},m.saveState=function(a){return m.isLastSavedState(a)?!1:(m.savedStates.push(m.cloneObject(a)),!0)},m.getStateByIndex=function(a){var b=null;return typeof a=="undefined"?b=m.savedStates[m.savedStates.length-1]:a<0?b=m.savedStates[m.savedStates.length+a]:b=m.savedStates[a],b},m.getHash=function(){var a=m.unescapeHash(d.location.hash);return a},m.unescapeString=function(b){var c=b,d;for(;;){d=a.unescape(c);if(d===c)break;c=d}return c},m.unescapeHash=function(a){var b=m.normalizeHash(a);return b=m.unescapeString(b),b},m.normalizeHash=function(a){var b=a.replace(/[^#]*#/,"").replace(/#.*/,"");return b},m.setHash=function(a,b){var c,e,f;return b!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.setHash,args:arguments,queue:b}),!1):(c=m.escapeHash(a),m.busy(!0),e=m.extractState(a,!0),e&&!m.emulated.pushState?m.pushState(e.data,e.title,e.url,!1):d.location.hash!==c&&(m.bugs.setHash?(f=m.getPageUrl(),m.pushState(null,null,f+"#"+c,!1)):d.location.hash=c),m)},m.escapeHash=function(b){var c=m.normalizeHash(b);return c=a.escape(c),m.bugs.hashEscape||(c=c.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),c},m.getHashByUrl=function(a){var b=String(a).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return b=m.unescapeHash(b),b},m.setTitle=function(a){var b=a.title,c;b||(c=m.getStateByIndex(0),c&&c.url===a.url&&(b=c.title||m.options.initialTitle));try{d.getElementsByTagName("title")[0].innerHTML=b.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(e){}return d.title=b,m},m.queues=[],m.busy=function(a){typeof a!="undefined"?m.busy.flag=a:typeof m.busy.flag=="undefined"&&(m.busy.flag=!1);if(!m.busy.flag){h(m.busy.timeout);var b=function(){var a,c,d;if(m.busy.flag)return;for(a=m.queues.length-1;a>=0;--a){c=m.queues[a];if(c.length===0)continue;d=c.shift(),m.fireQueueItem(d),m.busy.timeout=g(b,m.options.busyDelay)}};m.busy.timeout=g(b,m.options.busyDelay)}return m.busy.flag},m.busy.flag=!1,m.fireQueueItem=function(a){return a.callback.apply(a.scope||m,a.args||[])},m.pushQueue=function(a){return m.queues[a.queue||0]=m.queues[a.queue||0]||[],m.queues[a.queue||0].push(a),m},m.queue=function(a,b){return typeof a=="function"&&(a={callback:a}),typeof b!="undefined"&&(a.queue=b),m.busy()?m.pushQueue(a):m.fireQueueItem(a),m},m.clearQueue=function(){return m.busy.flag=!1,m.queues=[],m},m.stateChanged=!1,m.doubleChecker=!1,m.doubleCheckComplete=function(){return m.stateChanged=!0,m.doubleCheckClear(),m},m.doubleCheckClear=function(){return m.doubleChecker&&(h(m.doubleChecker),m.doubleChecker=!1),m},m.doubleCheck=function(a){return m.stateChanged=!1,m.doubleCheckClear(),m.bugs.ieDoubleCheck&&(m.doubleChecker=g(function(){return m.doubleCheckClear(),m.stateChanged||a(),!0},m.options.doubleCheckInterval)),m},m.safariStatePoll=function(){var b=m.extractState(d.location.href),c;if(!m.isLastSavedState(b))c=b;else return;return c||(c=m.createStateObject()),m.Adapter.trigger(a,"popstate"),m},m.back=function(a){return a!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.back,args:arguments,queue:a}),!1):(m.busy(!0),m.doubleCheck(function(){m.back(!1)}),n.go(-1),!0)},m.forward=function(a){return a!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.forward,args:arguments,queue:a}),!1):(m.busy(!0),m.doubleCheck(function(){m.forward(!1)}),n.go(1),!0)},m.go=function(a,b){var c;if(a>0)for(c=1;c<=a;++c)m.forward(b);else{if(!(a<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(c=-1;c>=a;--c)m.back(b)}return m};if(m.emulated.pushState){var o=function(){};m.pushState=m.pushState||o,m.replaceState=m.replaceState||o}else m.onPopState=function(b,c){var e=!1,f=!1,g,h;return m.doubleCheckComplete(),g=m.getHash(),g?(h=m.extractState(g||d.location.href,!0),h?m.replaceState(h.data,h.title,h.url,!1):(m.Adapter.trigger(a,"anchorchange"),m.busy(!1)),m.expectedStateId=!1,!1):(e=m.Adapter.extractEventData("state",b,c)||!1,e?f=m.getStateById(e):m.expectedStateId?f=m.getStateById(m.expectedStateId):f=m.extractState(d.location.href),f||(f=m.createStateObject(null,null,d.location.href)),m.expectedStateId=!1,m.isLastSavedState(f)?(m.busy(!1),!1):(m.storeState(f),m.saveState(f),m.setTitle(f),m.Adapter.trigger(a,"statechange"),m.busy(!1),!0))},m.Adapter.bind(a,"popstate",m.onPopState),m.pushState=function(b,c,d,e){if(m.getHashByUrl(d)&&m.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(e!==!1&&m.busy())return m.pushQueue({scope:m,callback:m.pushState,args:arguments,queue:e}),!1;m.busy(!0);var f=m.createStateObject(b,c,d);return m.isLastSavedState(f)?m.busy(!1):(m.storeState(f),m.expectedStateId=f.id,n.pushState(f.id,f.title,f.url),m.Adapter.trigger(a,"popstate")),!0},m.replaceState=function(b,c,d,e){if(m.getHashByUrl(d)&&m.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(e!==!1&&m.busy())return m.pushQueue({scope:m,callback:m.replaceState,args:arguments,queue:e}),!1;m.busy(!0);var f=m.createStateObject(b,c,d);return m.isLastSavedState(f)?m.busy(!1):(m.storeState(f),m.expectedStateId=f.id,n.replaceState(f.id,f.title,f.url),m.Adapter.trigger(a,"popstate")),!0};if(f){try{m.store=k.parse(f.getItem("History.store"))||{}}catch(p){m.store={}}m.normalizeStore()}else m.store={},m.normalizeStore();m.Adapter.bind(a,"beforeunload",m.clearAllIntervals),m.Adapter.bind(a,"unload",m.clearAllIntervals),m.saveState(m.storeState(m.extractState(d.location.href,!0))),f&&(m.onUnload=function(){var a,b;try{a=k.parse(f.getItem("History.store"))||{}}catch(c){a={}}a.idToState=a.idToState||{},a.urlToId=a.urlToId||{},a.stateToId=a.stateToId||{};for(b in m.idToState){if(!m.idToState.hasOwnProperty(b))continue;a.idToState[b]=m.idToState[b]}for(b in m.urlToId){if(!m.urlToId.hasOwnProperty(b))continue;a.urlToId[b]=m.urlToId[b]}for(b in m.stateToId){if(!m.stateToId.hasOwnProperty(b))continue;a.stateToId[b]=m.stateToId[b]}m.store=a,m.normalizeStore(),f.setItem("History.store",k.stringify(a))},m.intervalList.push(i(m.onUnload,m.options.storeInterval)),m.Adapter.bind(a,"beforeunload",m.onUnload),m.Adapter.bind(a,"unload",m.onUnload));if(!m.emulated.pushState){m.bugs.safariPoll&&m.intervalList.push(i(m.safariStatePoll,m.options.safariPollInterval));if(e.vendor==="Apple Computer, Inc."||(e.appCodeName||"")==="Mozilla")m.Adapter.bind(a,"hashchange",function(){m.Adapter.trigger(a,"popstate")}),m.getHash()&&m.Adapter.onDomLoad(function(){m.Adapter.trigger(a,"hashchange")})}},m.init()}(window);
;(function(a,b){function A(a,b){this._d=a,this._isUTC=!!b}function B(a){return a<0?Math.ceil(a):Math.floor(a)}function C(a){var b=this._data={},c=a.years||a.y||0,d=a.months||a.M||0,e=a.weeks||a.w||0,f=a.days||a.d||0,g=a.hours||a.h||0,h=a.minutes||a.m||0,i=a.seconds||a.s||0,j=a.milliseconds||a.ms||0;this._milliseconds=j+i*1e3+h*6e4+g*36e5,this._days=f+e*7,this._months=d+c*12,b.milliseconds=j%1e3,i+=B(j/1e3),b.seconds=i%60,h+=B(i/60),b.minutes=h%60,g+=B(h/60),b.hours=g%24,f+=B(g/24),f+=e*7,b.days=f%30,d+=B(f/30),b.months=d%12,c+=B(d/12),b.years=c}function D(a,b){var c=a+"";while(c.length<b)c="0"+c;return c}function E(a,b,c){var d=b._milliseconds,e=b._days,f=b._months,g;d&&a._d.setTime(+a+d*c),e&&a.date(a.date()+e*c),f&&(g=a.date(),a.date(1).month(a.month()+f*c).date(Math.min(g,a.daysInMonth())))}function F(a){return Object.prototype.toString.call(a)==="[object Array]"}function G(b){return new a(b[0],b[1]||0,b[2]||1,b[3]||0,b[4]||0,b[5]||0,b[6]||0)}function H(b,d){function q(d){var l,r;switch(d){case"M":return e+1;case"Mo":return e+1+o(e+1);case"MM":return D(e+1,2);case"MMM":return c.monthsShort[e];case"MMMM":return c.months[e];case"D":return f;case"Do":return f+o(f);case"DD":return D(f,2);case"DDD":return l=new a(g,e,f),r=new a(g,0,1),~~((l-r)/864e5+1.5);case"DDDo":return l=q("DDD"),l+o(l);case"DDDD":return D(q("DDD"),3);case"d":return h;case"do":return h+o(h);case"ddd":return c.weekdaysShort[h];case"dddd":return c.weekdays[h];case"w":return l=new a(g,e,f-h+5),r=new a(l.getFullYear(),0,4),~~((l-r)/864e5/7+1.5);case"wo":return l=q("w"),l+o(l);case"ww":return D(q("w"),2);case"YY":return D(g%100,2);case"YYYY":return g;case"a":return p?p(i,j,!1):i>11?"pm":"am";case"A":return p?p(i,j,!0):i>11?"PM":"AM";case"H":return i;case"HH":return D(i,2);case"h":return i%12||12;case"hh":return D(i%12||12,2);case"m":return j;case"mm":return D(j,2);case"s":return k;case"ss":return D(k,2);case"S":return~~(m/100);case"SS":return D(~~(m/10),2);case"SSS":return D(m,3);case"Z":return(n<0?"-":"+")+D(~~(Math.abs(n)/60),2)+":"+D(~~(Math.abs(n)%60),2);case"ZZ":return(n<0?"-":"+")+D(~~(10*Math.abs(n)/6),4);case"L":case"LL":case"LLL":case"LLLL":case"LT":return H(b,c.longDateFormat[d]);default:return d.replace(/(^\[)|(\\)|\]$/g,"")}}var e=b.month(),f=b.date(),g=b.year(),h=b.day(),i=b.hours(),j=b.minutes(),k=b.seconds(),m=b.milliseconds(),n=-b.zone(),o=c.ordinal,p=c.meridiem;return d.replace(l,q)}function I(a){switch(a){case"DDDD":return p;case"YYYY":return q;case"S":case"SS":case"SSS":case"DDD":return o;case"MMM":case"MMMM":case"ddd":case"dddd":case"a":case"A":return r;case"Z":case"ZZ":return s;case"T":return t;case"MM":case"DD":case"dd":case"YY":case"HH":case"hh":case"mm":case"ss":case"M":case"D":case"d":case"H":case"h":case"m":case"s":return n;default:return new RegExp(a.replace("\\",""))}}function J(a,b,d,e){var f;switch(a){case"M":case"MM":d[1]=b==null?0:~~b-1;break;case"MMM":case"MMMM":for(f=0;f<12;f++)if(c.monthsParse[f].test(b)){d[1]=f;break}break;case"D":case"DD":case"DDD":case"DDDD":d[2]=~~b;break;case"YY":b=~~b,d[0]=b+(b>70?1900:2e3);break;case"YYYY":d[0]=~~Math.abs(b);break;case"a":case"A":e.isPm=(b+"").toLowerCase()==="pm";break;case"H":case"HH":case"h":case"hh":d[3]=~~b;break;case"m":case"mm":d[4]=~~b;break;case"s":case"ss":d[5]=~~b;break;case"S":case"SS":case"SSS":d[6]=~~(("0."+b)*1e3);break;case"Z":case"ZZ":e.isUTC=!0,f=(b+"").match(x),f&&f[1]&&(e.tzh=~~f[1]),f&&f[2]&&(e.tzm=~~f[2]),f&&f[0]==="+"&&(e.tzh=-e.tzh,e.tzm=-e.tzm)}}function K(b,c){var d=[0,0,1,0,0,0,0],e={tzh:0,tzm:0},f=c.match(l),g,h;for(g=0;g<f.length;g++)h=(I(f[g]).exec(b)||[])[0],b=b.replace(I(f[g]),""),J(f[g],h,d,e);return e.isPm&&d[3]<12&&(d[3]+=12),e.isPm===!1&&d[3]===12&&(d[3]=0),d[3]+=e.tzh,d[4]+=e.tzm,e.isUTC?new a(a.UTC.apply({},d)):G(d)}function L(a,b){var c=Math.min(a.length,b.length),d=Math.abs(a.length-b.length),e=0,f;for(f=0;f<c;f++)~~a[f]!==~~b[f]&&e++;return e+d}function M(a,b){var c,d=a.match(m)||[],e,f=99,g,h,i;for(g=0;g<b.length;g++)h=K(a,b[g]),e=H(new A(h),b[g]).match(m)||[],i=L(d,e),i<f&&(f=i,c=h);return c}function N(b){var c="YYYY-MM-DDT",d;if(u.exec(b)){for(d=0;d<4;d++)if(w[d][1].exec(b)){c+=w[d][0];break}return s.exec(b)?K(b,c+" Z"):K(b,c)}return new a(b)}function O(a,b,d,e){var f=c.relativeTime[a];return typeof f=="function"?f(b||1,!!d,a,e):f.replace(/%d/i,b||1)}function P(a,b){var c=e(Math.abs(a)/1e3),d=e(c/60),f=e(d/60),g=e(f/24),h=e(g/365),i=c<45&&["s",c]||d===1&&["m"]||d<45&&["mm",d]||f===1&&["h"]||f<22&&["hh",f]||g===1&&["d"]||g<=25&&["dd",g]||g<=45&&["M"]||g<345&&["MM",e(g/30)]||h===1&&["y"]||["yy",h];return i[2]=b,i[3]=a>0,O.apply({},i)}function Q(a,b){c.fn[a]=function(a){var c=this._isUTC?"UTC":"";return a!=null?(this._d["set"+c+b](a),this):this._d["get"+c+b]()}}function R(a){c.duration.fn[a]=function(){return this._data[a]}}function S(a,b){c.duration.fn["as"+a]=function(){return+this/b}}var c,d="1.6.2",e=Math.round,f,g={},h="en",i=typeof module!="undefined",j="months|monthsShort|monthsParse|weekdays|weekdaysShort|longDateFormat|calendar|relativeTime|ordinal|meridiem".split("|"),k=/^\/?Date\((\-?\d+)/i,l=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|dddd?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?|LT|LL?L?L?)/g,m=/([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,n=/\d\d?/,o=/\d{1,3}/,p=/\d{3}/,q=/\d{4}/,r=/[0-9a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/i,s=/Z|[\+\-]\d\d:?\d\d/i,t=/T/i,u=/^\s*\d{4}-\d\d-\d\d(T(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,v="YYYY-MM-DDTHH:mm:ssZ",w=[["HH:mm:ss.S",/T\d\d:\d\d:\d\d\.\d{1,3}/],["HH:mm:ss",/T\d\d:\d\d:\d\d/],["HH:mm",/T\d\d:\d\d/],["HH",/T\d\d/]],x=/([\+\-]|\d\d)/gi,y="Month|Date|Hours|Minutes|Seconds|Milliseconds".split("|"),z={Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6};c=function(d,e){if(d===null||d==="")return null;var f,g,h;return c.isMoment(d)?(f=new a(+d._d),h=d._isUTC):e?F(e)?f=M(d,e):f=K(d,e):(g=k.exec(d),f=d===b?new a:g?new a(+g[1]):d instanceof a?d:F(d)?G(d):typeof d=="string"?N(d):new a(d)),new A(f,h)},c.utc=function(b,d){return F(b)?new A(new a(a.UTC.apply({},b)),!0):d&&b?c(b+" +0000",d+" Z").utc():c(b&&!s.exec(b)?b+"+0000":b).utc()},c.unix=function(a){return c(a*1e3)},c.duration=function(a,b){var d=c.isDuration(a),e=typeof a=="number",f=d?a._data:e?{}:a;return e&&(b?f[b]=a:f.milliseconds=a),new C(f)},c.humanizeDuration=function(a,b,d){return c.duration(a,b===!0?null:b).humanize(b===!0?!0:d)},c.version=d,c.defaultFormat=v,c.lang=function(a,b){var d,e,f=[];if(!a)return h;if(b){for(d=0;d<12;d++)f[d]=new RegExp("^"+b.months[d]+"|^"+b.monthsShort[d].replace(".",""),"i");b.monthsParse=b.monthsParse||f,g[a]=b}if(g[a]){for(d=0;d<j.length;d++)c[j[d]]=g[a][j[d]]||g.en[j[d]];h=a}else i&&(e=require("./lang/"+a),c.lang(a,e))},c.lang("en",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},meridiem:!1,calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},ordinal:function(a){var b=a%10;return~~(a%100/10)===1?"th":b===1?"st":b===2?"nd":b===3?"rd":"th"}}),c.isMoment=function(a){return a instanceof A},c.isDuration=function(a){return a instanceof C},c.fn=A.prototype={clone:function(){return c(this)},valueOf:function(){return+this._d},unix:function(){return Math.floor(+this._d/1e3)},toString:function(){return this._d.toString()},toDate:function(){return this._d},utc:function(){return this._isUTC=!0,this},local:function(){return this._isUTC=!1,this},format:function(a){return H(this,a?a:c.defaultFormat)},add:function(a,b){var d=b?c.duration(+b,a):c.duration(a);return E(this,d,1),this},subtract:function(a,b){var d=b?c.duration(+b,a):c.duration(a);return E(this,d,-1),this},diff:function(a,b,d){var f=this._isUTC?c(a).utc():c(a).local(),g=(this.zone()-f.zone())*6e4,h=this._d-f._d-g,i=this.year()-f.year(),j=this.month()-f.month(),k=this.date()-f.date(),l;return b==="months"?l=i*12+j+k/30:b==="years"?l=i+(j+k/30)/12:l=b==="seconds"?h/1e3:b==="minutes"?h/6e4:b==="hours"?h/36e5:b==="days"?h/864e5:b==="weeks"?h/6048e5:h,d?l:e(l)},from:function(a,b){return c.duration(this.diff(a)).humanize(!b)},fromNow:function(a){return this.from(c(),a)},calendar:function(){var a=this.diff(c().sod(),"days",!0),b=c.calendar,d=b.sameElse,e=a<-6?d:a<-1?b.lastWeek:a<0?b.lastDay:a<1?b.sameDay:a<2?b.nextDay:a<7?b.nextWeek:d;return this.format(typeof e=="function"?e.apply(this):e)},isLeapYear:function(){var a=this.year();return a%4===0&&a%100!==0||a%400===0},isDST:function(){return this.zone()<c([this.year()]).zone()||this.zone()<c([this.year(),5]).zone()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return a==null?b:this.add({d:a-b})},sod:function(){return c(this).hours(0).minutes(0).seconds(0).milliseconds(0)},eod:function(){return this.sod().add({d:1,ms:-1})},zone:function(){return this._isUTC?0:this._d.getTimezoneOffset()},daysInMonth:function(){return c(this).month(this.month()+1).date(0).date()}};for(f=0;f<y.length;f++)Q(y[f].toLowerCase(),y[f]);Q("year","FullYear"),c.duration.fn=C.prototype={weeks:function(){return B(this.days()/7)},valueOf:function(){return this._milliseconds+this._days*864e5+this._months*2592e6},humanize:function(a){var b=+this,d=c.relativeTime,e=P(b,!a);return a&&(e=(b<=0?d.past:d.future).replace(/%s/i,e)),e}};for(f in z)z.hasOwnProperty(f)&&(S(f,z[f]),R(f.toLowerCase()));S("Weeks",6048e5),i&&(module.exports=c),typeof window!="undefined"&&typeof ender=="undefined"&&(window.moment=c),typeof define=="function"&&define.amd&&define("moment",[],function(){return c})})(Date);
;$(document).ready(function() {

  var mediaData,
      progress;

  //
  //  jPlayer initialization.
  //

  // $('#jquery_jplayer_1').jPlayer({
  //   swfPath: "/js",
  //   supplied: 'mp3',
  //   // solution: 'html, flash',
  //   solution: 'flash, html',
  //   errorAlerts: false,
  //   volume: 0.5,
  //   play: function(d) {
  //     $('.podcast-player').css({'top': '0px'});
  //     $('.video-podcast-player').css({'top': '90px'});
  //     $('.video-player').fadeOut(300);
  //     $('.jp-playing').fadeIn(300);
  //     updatePlaying = setInterval(function(){
  //       updateStatus();
  //     }, 120000);
  //   },
  //   timeupdate: function(d) {
  //     progress = d.jPlayer.status.currentTime;
  //     playStatus(progress, mediaData);
  //   },
  //   pause: function(d) {
  //     clearInterval(updatePlaying);
  //   },
  //   ended: function(d) {
  //     clearInterval(updatePlaying);
  //     $('[data-uuid="' + mediaData.podcastID + '"]')
  //       .animate(
  //         { opacity: '0' },
  //         { duration: 600
  //       })
  //       .animate(
  //         { height: '0px', 'margin-bottom': '0px' },
  //         { duration: 600,
  //         complete: function() {
  //           $(this).remove();
  //           $('.jp-playing').fadeOut(300).html('');
  //         }
  //     });
  //     $.ajax({
  //       type: 'POST',
  //       url: '/listen/' + mediaData.feedUUID + '/listened/' + mediaData.podcastID,
  //       data: mediaData,
  //       success: function() {},
  //       error: function() {
  //         console.log('jPlayer had an error.');
  //       }
  //     });
  //   },
  //   error:function(d) {
  //     console.log('ERROR:' + d);
  //   },
  //   ready:function(d) {
  //     if (typeof(playing) !== 'undefined' && playing.podcast.indexOf('mp3') !== -1 ) {
  //       $('.podcast-player').css({'top': '0px'});
  //       mediaData = playing;
  //       playStatus(playing.progress, playing);
  //       $('#jquery_jplayer_1').jPlayer("setMedia", {
  //         mp3: playing.podcast
  //       }).jPlayer('pause', Math.round(playing.progress));
  //     }
  //   }
  // });

  // $('#jquery_jplayer_2').jPlayer({
  //   swfPath: "/js",
  //   supplied: 'm4v, m4a',
  //   // solution: 'html, flash',
  //   solution: 'html, flash',
  //   volume: 0.5,
  //   cssSelectorAncestor: "#jp_container_2",
  //   errorAlerts: false,
  //   play: function(d) {
  //     $('.podcast-player').css({'top': '90px'});
  //     $('.video-podcast-player').css({'top': '0px'});
  //     $('.video-player').fadeIn(300);
  //     $('#jquery_jplayer_2').fadeIn(300);
  //     $('.jp-playing').fadeIn(300);
  //     updatePlaying = setInterval(function(){
  //       updateStatus();
  //     }, 120000);
  //   },
  //   timeupdate: function(d) {
  //     progress = d.jPlayer.status.currentTime;
  //     playStatus(progress, mediaData);
  //   },
  //   pause: function(d) {
  //     clearInterval(updatePlaying);
  //   },
  //   ended: function(d) {
  //     clearInterval(updatePlaying);
  //     $('.video-player').fadeOut(300)
  //     $('#jquery_jplayer_2').fadeOut(300)
  //     $('[data-uuid="' + mediaData.podcastID + '"]')
  //       .animate(
  //         { opacity: '0' },
  //         { duration: 600
  //       })
  //       .animate(
  //         { height: '0px', 'margin-bottom': '0px' },
  //         { duration: 600,
  //         complete: function() {
  //           $(this).remove();
  //           $('.jp-playing').fadeOut(300).html('');
  //         }
  //     });
  //     $.ajax({
  //       type: 'POST',
  //       url: '/listen/' + mediaData.feedUUID + '/listened/' + mediaData.podcastID,
  //       data: mediaData,
  //       success: function() {},
  //       error: function() {
  //         console.log('jPlayer had an error.');
  //       }
  //     });
  //   },
  //   error:function(d) {
  //     console.log('ERROR:' + d);
  //   },
  //   ready:function(d) {
  //     console.log(playing.podcast.indexOf('mp4'));
  //     if (typeof(playing) !== 'undefined' && playing.podcast.indexOf('mp4') !== -1 ) {
  //       $('.podcast-player').css({'top': '90px'});
  //       $('.video-podcast-player').css({'top': '0px'});
  //       $('#jquery_jplayer_2').fadeIn(300);
  //       mediaData = playing;
  //       playStatus(playing.progress, playing);
  //       $('#jquery_jplayer_2').jPlayer("setMedia", {
  //         m4v: playing.podcast
  //       }).jPlayer('pause', Math.round(playing.progress));
  //     }
  //   }
  // });

  //
  //  Manual synchronization.
  //

  // $('.manual-sync').click(function(e) {
  //   if ( $('#jquery_jplayer_1').data().jPlayer.status.paused === false ) {
  //     progress = $('#jquery_jplayer_1').data("jPlayer").status.currentTime;
  //   } else if ( $('#jquery_jplayer_2').data().jPlayer.status.paused === false ) {
  //     progress = $('#jquery_jplayer_2').data("jPlayer").status.currentTime;
  //   }
  //   playStatus(progress, mediaData);
  //   updateStatus();
  // });

  //
  //  Mark a podcast as "listened."
  //

  $(document).delegate('.podcastListened', 'click', function(e) {
    e.preventDefault();
    var split = this.className.split(' ');
    var delegator = split[1];

    if ( delegator === 'all' ) {
      var data = {
        id : $(this).attr('href').split('/')[4],
        feed : $(this).attr('href').split('/')[2]
      };
      $(this).parent().parent().parent()
        // Why .parent('.podcastItem') doesn't work counfounds and annoys me.
        .animate(
          { opacity: '0' },
          { duration: 600
        })
        .animate(
          { height: '0px', 'margin-bottom': '0px' },
          { duration: 600,
          complete: function() {
            $(this).remove();
      leftFixHeight();
          }
        });
      $.ajax({
        type: 'POST',
        url: '/listen/' + data.feed + '/listened/' + data.id,
        data: data,
        success: function(data) {
          console.log('Marked as listened!' + data)
        },
        error: function(data) {
          console.log('Hark had an error.' + data);
        }
      });
    } else if ( delegator === 'single' ) {
      var data = {
        id : $(this).attr('href').split('/')[4],
        feed : $(this).attr('href').split('/')[2]
      };
      $('#' + data.id).removeClass('false');
      $.ajax({
        type: 'POST',
        url: '/listen/' + data.feed + '/listened/' + data.id,
        data: data,
        success: function() {  },
        error: function() {
          console.log('Hark had an error.');
        }
      });
    }
  });

  $(document).delegate('.act-mark.active', 'click', function(e) {

    var split = $('.selected').attr('class').split(/\s+/);
    var delegator = split[1];
    var data = {
      podcastID: $('.selected').attr("data-uuid"),
      feedUUID: $('.selected').attr("data-feedUUID")
    }

    if ( delegator === 'all' ) {
      $('.selected')
        .animate(
          { opacity: '0' },
          { duration: 600
        })
        .animate(
          { height: '0px', 'margin-bottom': '0px' },
          { duration: 600,
          complete: function() {
            $(this).remove();
      
      leftFixHeight();
          }
        });
      $.ajax({
        type: 'POST',
        url: '/listen/' + data.feedUUID + '/listened/' + data.podcastID,
        data: data,
        success: function(data) {
          console.log('Marked as listened!' + data)
        },
        error: function(data) {
          console.log('Hark had an error.' + data);
        }
      });
    } else if ( delegator === 'single' ) {
      $('#' + data.podcastID).removeClass('false');
      $.ajax({
        type: 'POST',
        url: '/listen/' + data.feed + '/listened/' + data.id,
        data: data,
        success: function(data) {
          console.log('Marked as listened!' + data)
        },
        error: function() {
          console.log('Hark had an error.');
        }
      });
    }
  });

  //
  // Listen to a podcast.
  //

  // $(document).delegate('.podcastListen', 'click', function(e) {
  //   e.preventDefault();
  //   mediaData = {
  //     podcast: $(this).attr("data-file"),
  //     podcastTitle: $(this).attr("data-title"),
  //     podcastID: $(this).attr('href').split('/')[3],
  //     feedUUID: $(this).attr('href').split('/')[2],
  //     feedTitle: $(this).attr("data-feed")
  //   }
  //   if ( mediaData.podcast.indexOf('mp4') == -1 ) {
  //     $('#jquery_jplayer_1').jPlayer("pauseOthers").jPlayer("setMedia", {
  //       mp3: mediaData.podcast
  //     }).jPlayer('play');
  //   }
  //   else {
  //     $('#jquery_jplayer_2').jPlayer("pauseOthers").jPlayer("setMedia", {
  //       m4v: mediaData.podcast
  //     }).jPlayer('play');
  //   }
  //   $.ajax({
  //     type: 'POST',
  //     url: '/listen/' + mediaData.feedUUID + '/' + mediaData.podcastID,
  //     data: mediaData,
  //     success: function(data) {
  //       console.log(data);
  //       $('.currently-playing').html(data);
  //     }
  //   });
  // });

  // $(document).delegate('.act-listen.active', 'click', function(e) {
  //   mediaData = {
  //     podcast: $('.selected').attr("data-file"),
  //     podcastTitle: $('.selected').attr("data-title"),
  //     podcastID: $('.selected').attr("data-uuid"),
  //     feedUUID: $('.selected').attr("data-feedUUID"),
  //     feedTitle: $('.selected').attr("data-feed")
  //   }
  //   if ( mediaData.podcast.indexOf('mp4') == -1 ) {
  //     $('#jquery_jplayer_1').jPlayer("pauseOthers").jPlayer("setMedia", {
  //       mp3: mediaData.podcast
  //     }).jPlayer('play');
  //   }
  //   else {
  //     $('#jquery_jplayer_2').jPlayer("pauseOthers").jPlayer("setMedia", {
  //       m4v: mediaData.podcast
  //     }).jPlayer('play');
  //   }
  //   $.ajax({
  //     type: 'POST',
  //     url: '/listen/' + mediaData.feedUUID + '/' + mediaData.podcastID,
  //     data: mediaData,
  //     success: function(data) {
  //       $('.currently-playing').html(data);
  //     }
  //   });
  // });


  //
  //  Settings.
  //

  // $(document).delegate('.delete', 'click', function(e) {
  //   e.preventDefault();
  //   $('.settings-mask').fadeIn(200);
  //   $('.settings-modal-error').fadeIn(200);
  // });

  // $(document).delegate('.delete-confirm', 'click', function(e) {
  //   e.preventDefault();
  //   $.ajax({
  //     type: 'POST',
  //     url: '/settings/delete',
  //     success: function(data) {
  //       console.log('Deleted!');
  //     }
  //   });
  // });

  //
  //  Play status.
  //

  // function playStatus(progress, mediaData) {
  //   sessionStorage.setItem("podcast", mediaData.podcast);
  //   sessionStorage.setItem("podcastID", mediaData.podcastID);
  //   sessionStorage.setItem("feedUUID", mediaData.feedUUID);
  //   sessionStorage.setItem("feedTitle", mediaData.feedTitle);
  //   sessionStorage.setItem("podcastTitle", mediaData.podcastTitle);
  //   sessionStorage.setItem("progress", progress);
  // }

  // function updateStatus() {
  //   var playing = {
  //     "podcast" : sessionStorage.getItem("podcast"),
  //     "podcastID" : sessionStorage.getItem("podcastID"),
  //     "podcastTitle" : sessionStorage.getItem("podcastTitle"),
  //     "feedTitle" : sessionStorage.getItem("feedTitle"),
  //     "feedUUID" : sessionStorage.getItem("feedUUID"),
  //     "progress" : sessionStorage.getItem("progress")
  //   }
  //   $.ajax({
  //     type: 'POST',
  //     url: '/listen/playing',
  //     data: playing,
  //     success: function(data) {
  //       console.log('Sync-ed! ' + data);
  //     },
  //     error: function(data) {
  //       console.log('Error with syncing! ' + data);
  //       return;
  //     }
  //   });
  // }

});
;(function() {
  var wookmark;

  wookmark = function() {};

  $(document).delegate('.directory-feed-subscribe', 'click', function(e) {
    e.preventDefault();
    return $.ajax({
      type: 'POST',
      url: $(e.currentTarget).attr('href'),
      error: function(err) {
        $('#modal').html($(err.responseText));
        return $('#modal').fadeIn(500);
      },
      success: function(data, textStatus, jqXHR) {
        return $(e.currentTarget).text('Subscribed!');
      }
    });
  });

  $(document).delegate('.category a:not(.loadAll)', 'click', function(e) {
    e.preventDefault();
    return $.ajax({
      type: 'POST',
      url: $(this).attr('href'),
      data: $(this).attr('href'),
      success: function(data) {
        $('.primary').html(data);
        console.log(data);
        ajaxHelpers();
        return window.dir_pagination();
      }
    });
  }).delegate('.category a.loadAll', 'click', function(e) {
    e.preventDefault();
    return $.ajax({
      type: 'POST',
      url: $(this).attr('href'),
      data: $(this).attr('href'),
      success: function(data) {
        $('.hark-container').html(data);
        ajaxHelpers();
        return window.dir_pagination();
      }
    });
  });

  $(document).on('click', '.directory-sort-popularity', function(e) {
    if ($(this).is('.desc')) {
      $('.directory-item').tsort({
        attr: 'data-subs'
      });
      return $('.directory-sort-popularity').removeClass('desc').addClass('asc');
    } else {
      $('.directory-item').tsort({
        order: 'desc',
        attr: 'data-subs'
      });
      return $('.directory-sort-popularity').removeClass('asc').addClass('desc');
    }
  });

  $(document).on('click', '.directory-sort-alphabetical', function(e) {
    if ($(this).is('.desc')) {
      $('.directory-item').tsort($(this).children('h1').text(), {
        order: 'desc'
      });
      return $('.directory-sort-alphabetical').removeClass('desc').addClass('asc');
    } else {
      $('.directory-item').tsort($(this).children('h1').text(), {
        order: 'asc'
      });
      return $('.directory-sort-alphabetical').removeClass('asc').addClass('desc');
    }
  });

  $(document).on('click', '.directory-sort-latest', function(e) {
    if ($(this).is('.desc')) {
      $('.directory-item').tsort({
        attr: 'data-date'
      });
      return $('.directory-sort-latest').removeClass('desc').addClass('asc');
    } else {
      $('.directory-item').tsort({
        order: 'desc',
        attr: 'data-date'
      });
      return $('.directory-sort-latest').removeClass('asc').addClass('desc');
    }
  });

  $(document).on('click', '.directory-sort-pure-alpha', function(e) {
    var category;
    e.preventDefault();
    category = null;
    if (typeof (top.location.pathname.split('/')[3]) !== 'undefined') {
      category = top.location.pathname.split('/')[3];
    }
    return $.ajax({
      type: 'POST',
      url: '/directory/sort-title',
      data: {
        category: category
      },
      success: function(data) {
        $('.hark-container').html(data);
        return ajaxHelpers();
      }
    });
  });

  window.dir_pagination = function() {
    var current_page, next_page, prev_page;
    current_page = parseInt($('.directory-main').attr('data-page'));
    if (current_page === 1) {
      $('.pagination-next').attr('href', '/directory/page/2');
      return $('.pagination-prev').css({
        'opacity': 0
      });
    } else {
      prev_page = current_page - 1;
      next_page = current_page + 1;
      $('.pagination-prev').attr('href', '/directory/page/' + prev_page);
      return $('.pagination-next').attr('href', '/directory/page/' + next_page);
    }
  };

  $(document).on('click', '.pagination-prev', function(e) {
    var category;
    e.preventDefault();
    category = null;
    if (typeof (top.location.pathname.split('/')[3]) !== 'undefined') {
      category = top.location.pathname.split('/')[3];
    }
    return $.ajax({
      type: 'POST',
      url: $(this).attr('href'),
      data: {
        category: category
      },
      success: function(data) {
        $('.hark-container').html(data);
        ajaxHelpers();
        return window.dir_pagination();
      }
    });
  });

  $(document).on('click', '.pagination-next', function(e) {
    var category;
    e.preventDefault();
    category = null;
    if (typeof (top.location.pathname.split('/')[3]) !== 'undefined') {
      category = top.location.pathname.split('/')[3];
    }
    return $.ajax({
      type: 'POST',
      url: $(this).attr('href'),
      data: {
        category: category
      },
      success: function(data) {
        $('.hark-container').html(data);
        ajaxHelpers();
        return window.dir_pagination();
      }
    });
  });

}).call(this);

(function() {

  window.settings = function() {
    $(document).delegate('.delete', 'click', function(e) {
      e.preventDefault();
      return $('.settings-mask, .settings-modal-error').fadeIn(200);
    });
    return $(document).delegate('.delete-confirm', 'click', function(e) {
      e.preventDefault();
      return $.ajax({
        type: 'POST',
        url: '/settings/delete',
        success: function(data) {
          return console.log('Deleted!');
        }
      });
    });
  };

}).call(this);

(function() {
  var $, History, State, dir_pagination, listenHeight, mediaData, momentize, path, progress, sidebarHeight, siteUrl;

  $ = jQuery;

  History = State = progress = path = dir_pagination = mediaData = progress = null;

  $(document).ready(function() {
    console.log(playing);
    window.ajaxHelpers();
    State = History.getState();
    window.dir_pagination();
    window.settings();
  });

  window.onload = function() {
    window.jplayer_1();
    window.jplayer_2();
    return window.jplayer();
  };

  window.onresize = function(event) {
    sidebarHeight();
    return listenHeight();
  };

  window.ajaxHelpers = function() {
    sidebarHeight();
    listenHeight();
    momentize();
    return $('#loading').fadeOut(300);
  };

  History = window.History;

  siteUrl = "http://" + top.location.host.toString();

  $(document).delegate('a:not(.history-ignore)[href="/listen"], \
             a[href="/directory"],\
             a[href="/settings"],\
             a[href="/help"],\
             a[href^="/listen/podcast/"],\
             a[href^="/directory/category/"]', "click", function(e) {
    e.preventDefault();
    State = History.getState();
    path = $(e.currentTarget).text();
    return History.pushState({}, "", $(e.currentTarget).attr('href'));
  });

  History.Adapter.bind(window, 'statechange', function() {
    $('#loading').fadeIn(300);
    State = History.getState();
    History.log(State.data, State.title, State.url, State.hash);
    if (State.hash === '/listen' || State.hash === '/listen/') {
      return $.ajax({
        type: 'POST',
        url: '/listen',
        success: function(data) {
          $('.hark-container').replaceWith(data);
          document.title = 'Hark | Your podcasts';
          return window.ajaxHelpers();
        }
      });
    } else if (State.hash === '/directory' || State.hash === '/directory/') {
      return $.ajax({
        type: 'POST',
        url: '/directory',
        success: function(data) {
          $('.hark-container').html(data);
          window.dir_pagination();
          document.title = 'Hark | The Directory';
          return window.ajaxHelpers();
        }
      });
    } else if (State.hash === '/settings' || State.hash === '/settings/') {
      return $.ajax({
        type: 'POST',
        url: '/settings',
        success: function(data) {
          $('.hark-container').html(data);
          document.title = 'Hark | Your settings';
          return window.ajaxHelpers();
        }
      });
    } else if (State.hash === '/help' || State.hash === '/help/') {
      return $.ajax({
        type: 'POST',
        url: '/help',
        success: function(data) {
          $('.hark-container').html(data);
          document.title = 'Hark | FAQ & Help';
          return window.ajaxHelpers();
        }
      });
    } else if (State.hash.indexOf('/listen/podcast/') !== -1) {
      return $.ajax({
        type: 'POST',
        data: {
          feedID: State.hash.split('/')[3]
        },
        url: State.hash,
        success: function(data) {
          $('.primary').html(data);
          document.title = 'Hark | ' + $(data).find('.podcast-item:first-of-type').attr('data-feed');
          return window.ajaxHelpers();
        }
      });
    } else if (State.hash.indexOf('/directory/category/') !== -1) {
      return $.ajax({
        type: 'POST',
        data: {
          feedID: State.hash.split('/')[3]
        },
        url: State.hash,
        success: function(data) {
          $('.primary').html(data);
          window.dir_pagination();
          return window.ajaxHelpers();
        }
      });
    } else {

    }
  });

  $(document).delegate('.current-item, .current-feed', 'click', function(e) {
    var data;
    e.preventDefault();
    if ($(e.currentTarget).is('.blank')) {
      console.log('blank');
    } else {
      data = {
        feedID: $(this).attr('href').split('/')[3]
      };
      return $.ajax({
        type: 'POST',
        data: data,
        url: '/listen/podcast/' + data.feedID,
        success: function(data) {
          $('.primary').html(data);
          return window.ajaxHelpers();
        }
      });
    }
  });

  sidebarHeight = function() {
    var c_height, c_width, sidebar;
    c_width = $(window).width();
    c_height = $(window).height();
    sidebar = $('.sidebar');
    return $('.sidebar').css('height', c_height - 171);
  };

  listenHeight = function() {
    var c_height, c_width, listen;
    c_width = $(window).width();
    c_height = $(window).height();
    listen = $('.primary');
    return $('.primary').css('height', c_height - 171);
  };

  $('.modal-close').live('click', function(e) {
    return $('#modal').fadeOut(200);
  });

  $(document).delegate('.categories li:not(.safe), .subscriptions li:not(.safe), .currently-playing li:not(.heading), .choose-settings li:not(.safe), .questions li:not(.safe)', 'hover', function(e) {
    if (e.type === 'mouseenter') {
      return $('.hover-er').css('top', $(e.currentTarget).offset().top + 0).css('opacity', '100').css('height', $(e.currentTarget).height());
    } else {
      if ($(e.currentTarget).children('.sidebar-expander').is('.expanded')) {

      } else {
        return $('.hover-er').css('opacity', '0');
      }
    }
  });

  momentize = function() {
    return $('.moment').each(function(i) {
      $(this).attr('data-date', $(this).text());
      return $(this).text(moment($(this).text()).fromNow());
    });
  };

}).call(this);

(function() {
  var mediaData, progress;

  window.mediaData = progress = null;

  mediaData = window.mediaData;

  window.jplayer_1 = function() {
    return $('#jquery_jplayer_1').jPlayer({
      swfPath: "/js",
      supplied: 'mp3',
      solution: 'flash, html',
      errorAlerts: false,
      volume: 0.5,
      play: function(d) {
        var updatePlaying;
        $('.podcast-player').css({
          'top': '0px'
        });
        $('.video-podcast-player').css({
          'top': '90px'
        });
        $('.video-player').fadeOut(300);
        $('.jp-playing').fadeIn(300);
        return updatePlaying = setInterval((function() {
          return window.updateStatus();
        }), 120000);
      },
      timeupdate: function(d) {
        progress = d.jPlayer.status.currentTime;
        return window.playStatus(progress, window.mediaData);
      },
      pause: function(d) {
        return clearInterval(window.updatePlaying);
      },
      ended: function(d) {
        clearInterval(window.updatePlaying);
        return $.ajax({
          type: 'POST',
          url: '/listen/' + window.mediaData.feedUUID + '/listened/' + window.mediaData.podcastID,
          data: window.mediaData,
          success: function() {
            return console.log('jPlayer ended.');
          },
          error: function() {
            return console.log('jPlayer had an error.');
          }
        });
      },
      error: function(d) {
        console.log('ERROR:');
        return console.log(d);
      },
      ready: function(d) {
        if (typeof playing !== 'undefined' && playing.podcast.indexOf('mp3') !== -1) {
          console.log('fired');
          $('.podcast-player').css({
            'top': '0px'
          });
          window.mediaData = playing;
          window.playStatus(playing.progress, playing);
          return $('#jquery_jplayer_1').jPlayer("setMedia", {
            mp3: playing.podcast
          }).jPlayer('pause', Math.round(playing.progress));
        }
      }
    });
  };

  window.jplayer_2 = function() {
    return $('#jquery_jplayer_2').jPlayer({
      swfPath: "/js",
      supplied: 'm4v, m4a',
      solution: 'html, flash',
      errorAlerts: false,
      cssSelectorAncestor: "#jp_container_2",
      volume: 0.0,
      play: function(d) {
        var updatePlaying;
        $('.podcast-player').css({
          'top': '90px'
        });
        $('.video-podcast-player').css({
          'top': '0px'
        });
        $('.video-player').css({
          'top': $(document).height() - $('.video-player').height() - 90
        });
        $('.video-player, #jquery_jplayer_2, .jp-playing').fadeIn(300);
        return updatePlaying = setInterval((function() {
          return window.updateStatus();
        }), 120000);
      },
      timeupdate: function(d) {
        progress = d.jPlayer.status.currentTime;
        return window.playStatus(progress, window.mediaData);
      },
      pause: function(d) {
        return clearInterval(window.updatePlaying);
      },
      ended: function(d) {
        clearInterval(window.updatePlaying);
        $('.video-player, #jquery_jplayer_2').fadeOut(300);
        return $.ajax({
          type: 'POST',
          url: '/listen/' + window.mediaData.feedUUID + '/listened/' + window.mediaData.podcastID,
          data: window.mediaData,
          success: function() {
            return console.log('jPlayer ended.');
          },
          error: function() {
            return console.log('jPlayer had an error.');
          }
        });
      },
      error: function(d) {
        return console.log('ERROR:' + d);
      },
      ready: function(d) {
        if (typeof playing !== 'undefined' && playing.podcast.indexOf('mp4') !== -1) {
          $('.podcast-player').css({
            'top': '90px'
          });
          $('.video-podcast-player').css({
            'top': '0px'
          });
          $('#jquery_jplayer_2').fadeIn(300);
          window.mediaData = playing;
          window.playStatus(playing.progress, playing);
          return $('#jquery_jplayer_2').jPlayer("setMedia", {
            m4v: playing.podcast
          }).jPlayer('pause', Math.round(playing.progress));
        }
      }
    });
  };

  window.playStatus = function(progress, mediaData) {
    sessionStorage.setItem("podcast", window.mediaData.podcast);
    sessionStorage.setItem("podcastID", window.mediaData.podcastID);
    sessionStorage.setItem("feedUUID", window.mediaData.feedUUID);
    sessionStorage.setItem("feedTitle", window.mediaData.feedTitle);
    sessionStorage.setItem("podcastTitle", window.mediaData.podcastTitle);
    return sessionStorage.setItem("progress", progress);
  };

  window.updateStatus = function() {
    var playing;
    playing = {
      "podcast": sessionStorage.getItem("podcast"),
      "podcastID": sessionStorage.getItem("podcastID"),
      "podcastTitle": sessionStorage.getItem("podcastTitle"),
      "feedTitle": sessionStorage.getItem("feedTitle"),
      "feedUUID": sessionStorage.getItem("feedUUID"),
      "progress": sessionStorage.getItem("progress")
    };
    return $.ajax({
      type: 'POST',
      url: '/listen/playing',
      data: playing,
      success: function(data) {
        return console.log('Sync-ed! ' + data);
      },
      error: function(data) {
        console.log('Error with syncing! ' + data);
      }
    });
  };

  window.jplayer = function() {
    $('.manual-sync').click(function(e) {
      if ($('#jquery_jplayer_1').data().jPlayer.status.paused === false) {
        progress = $('#jquery_jplayer_1').data("jPlayer").status.currentTime;
      } else if ($('#jquery_jplayer_2').data().jPlayer.status.paused === false) {
        progress = $('#jquery_jplayer_2').data("jPlayer").status.currentTime;
      } else {
        console.log('WTF');
      }
      console.log(progress, window.mediaData);
      window.playStatus(progress, window.mediaData);
      return window.updateStatus();
    });
    $('body').delegate('.video-move', 'mousedown', function(e) {
      return $(window).bind('mousemove', function(e) {
        e.preventDefault();
        $('.video-player').removeClass('minimized');
        return $('.video-player').css({
          'top': e.clientY - 20,
          'left': e.clientX - 12,
          'margin-left': ''
        });
      });
    }).delegate('.video-move', 'mouseup', function(e) {
      $('.video-move').undelegate();
      return $(window).unbind('mousemove');
    });
    $('body').on('click', '.video-minimize', function(e) {
      var half_width, pos;
      if ($('.video-player').is('.minimized')) {
        $('.video-player').removeClass('minimized');
        half_width = $('.video-player').width() / 2;
        pos = $(window).width() - half_width;
        return $('.video-player').css({
          'bottom': 100 + 'px',
          'left': '50%',
          'margin-left': -half_width + 'px'
        });
      } else {
        $('.video-player').addClass('minimized');
        pos = $(window).width() - $('.video-player').width() / 2;
        return $('.video-player').css({
          'bottom': -180 + 'px',
          'left': pos,
          'top': '',
          'margin-left': ''
        });
      }
    });
    return $(document).on('mousedown', '.video-resize', function(e) {
      var i_f;
      i_f = $('.video-player').offset().top + $('.video-player').height();
      $(window).bind('mousemove', function(e) {
        e.preventDefault();
        $('.video-player').css({
          'top': e.clientY - 12,
          'width': e.clientX - $('.video-player').offset().left + 12,
          'height': i_f - $('.video-player').offset().top + 12,
          'padding-bottom': 4
        });
        return $('#jquery_jplayer_2, #jp_video_1').css({
          'height': '100%',
          'width': '100%'
        });
      });
      return $('*').onselectstart;
    }).on('mouseup', function(e) {
      $('.video-resize').off;
      return $(window).unbind('mousemove');
    });
  };

}).call(this);

(function() {

  $(document).delegate('.act-listen.active', 'click', function(e) {
    window.mediaData = {
      podcast: $('.selected').attr("data-file"),
      podcastTitle: $('.selected').attr("data-title"),
      podcastID: $('.selected').attr("data-uuid"),
      feedUUID: $('.selected').attr("data-feedUUID"),
      feedTitle: $('.selected').attr("data-feed")
    };
    if (window.mediaData.podcast.indexOf('mp4') === -1) {
      $('#jquery_jplayer_1').jPlayer("pauseOthers").jPlayer("setMedia", {
        mp3: window.mediaData.podcast
      }).jPlayer('play');
    } else {
      $('#jquery_jplayer_2').jPlayer("pauseOthers").jPlayer("setMedia", {
        m4v: window.mediaData.podcast
      }).jPlayer('play');
    }
    return $.ajax({
      type: 'POST',
      url: '/listen/' + window.mediaData.feedUUID + '/' + window.mediaData.podcastID,
      data: window.mediaData,
      success: function(data) {
        return $('.currently-playing').html(data);
      }
    });
  });

  $(document).delegate('.podcastListen', 'click', function(e) {
    e.preventDefault();
    window.mediaData = {
      podcast: $(this).attr("data-file"),
      podcastTitle: $(this).attr("data-title"),
      podcastID: $(this).attr('href').split('/')[3],
      feedUUID: $(this).attr('href').split('/')[2],
      feedTitle: $(this).attr("data-feed")
    };
    if (window.mediaData.podcast.indexOf('mp4') === -1) {
      $('#jquery_jplayer_1').jPlayer("pauseOthers").jPlayer("setMedia", {
        mp3: window.mediaData.podcast
      }).jPlayer('play');
    } else {
      $('#jquery_jplayer_2').jPlayer("pauseOthers").jPlayer("setMedia", {
        m4v: window.mediaData.podcast
      }).jPlayer('play');
    }
    return $.ajax({
      type: 'POST',
      url: '/listen/' + window.mediaData.feedUUID + '/' + window.mediaData.podcastID,
      data: window.mediaData,
      success: function(data) {
        return $('.currently-playing').html(data);
      }
    });
  });

  $(document).delegate('.act-add', 'click', function(e) {
    e.preventDefault();
    return $('.add-feed').toggle();
  });

  $('.add-feed').live('keypress', function(e) {
    var data;
    if (e.which === 13) {
      data = {
        url: $(e.currentTarget).val()
      };
      return $.ajax({
        type: 'POST',
        url: '/listen/add',
        data: data,
        error: function(err) {
          $('#modal').html(err.responseText);
          return $('#modal').fadeIn(500);
        },
        success: function(data) {
          $('.hark-container').html(data);
          $('.add-feed').val('');
          $('.add-feed').hide();
          return window.ajaxHelpers();
        }
      });
    }
  });

  $(document).delegate('.act-update', 'click', function(e) {
    e.preventDefault();
    $('.act-update a').text('Updating...');
    return $.ajax({
      type: 'POST',
      url: '/listen/update',
      error: function(err) {
        $('#modal').html(err.responseText);
        return $('#modal').fadeIn(500);
      },
      success: function(data) {
        $('.act-update a').text('Update');
        $('.primary').html(data);
        return window.ajaxHelpers();
      }
    });
  });

  $(document).delegate('.allFeeds a', 'click', function(e) {
    e.preventDefault();
    return $.ajax({
      type: 'POST',
      url: '/listen/podcast/all',
      success: function(data) {
        $('.primary').html(data);
        return window.ajaxHelpers();
      }
    });
  });

  $(document).delegate('.loadFeed, .loadFeedFromItem', 'click', function(e) {
    var data;
    e.preventDefault();
    data = {
      feedID: $(this).attr('href').split('/')[3]
    };
    return $.ajax({
      type: 'POST',
      data: data,
      url: '/listen/podcast/' + data.feedID,
      success: function(data) {
        $('.primary').html(data);
        return window.ajaxHelpers();
      }
    });
  });

  $(document).delegate('.sidebar-expander', 'click', function(e) {
    if ($(e.currentTarget).is('.expanded')) {
      $(e.currentTarget).next().removeClass('undocked').fadeOut(300);
      $(e.currentTarget).parent().removeClass('active');
      return $(e.currentTarget).removeClass('expanded');
    } else {
      $('.sidebar-action-edit-input').hide();
      $(e.currentTarget).parent().css('overflow', 'visible');
      $(e.currentTarget).next().addClass('undocked').fadeIn(300);
      $(e.currentTarget).parent().addClass('active');
      return $(e.currentTarget).addClass('expanded');
    }
  });

  $(document).delegate('.sidebar-action-edit', 'click', function(e) {
    e.preventDefault();
    $('.sidebar-action-edit-input').val('');
    $('.sidebar-action-edit-input').fadeIn(300);
    return $('.sidebar-action-edit-input').val($(e.currentTarget).parent().siblings('.loadFeed').text());
  });

  $('.sidebar-action-edit-input').live('keypress', function(e) {
    var data;
    if (e.which === 13) {
      data = {
        feedID: $(this).prev().attr('href').split('/')[3],
        feedName: $(this).val()
      };
      console.log(data);
      return $.ajax({
        type: 'POST',
        data: data,
        url: '/listen/edit/' + data.feedID,
        success: function(data) {
          $('.hark-container').html(data);
          return window.ajaxHelpers();
        }
      });
    }
  });

  $(document).delegate('.sidebar-action-remove', 'click', function(e) {
    var data;
    e.preventDefault();
    data = {
      feedID: $(e.currentTarget).attr('href').split('/')[3]
    };
    return $.ajax({
      type: 'POST',
      data: data,
      url: '/listen/remove/' + data.feedID,
      success: function(data) {
        console.log(data);
        $('.hark-container').html(data);
        return window.ajaxHelpers();
      }
    });
  });

  $(document).delegate('.podcast-item:not(.selected)', 'click', function(e) {
    $('.podcast-item').removeClass('selected');
    $(e.currentTarget).addClass('selected');
    return $('.act-listen, .act-mark, .act-read, .act-source, .act-download').removeClass('inactive').addClass('active');
  });

  $(document).delegate('.selected', 'click', function(e) {
    $(e.currentTarget).removeClass('selected');
    return $('.act-listen, .act-mark, .act-read, .act-source, .act-download').removeClass('active').addClass('inactive');
  });

  $(document).delegate('.item-actions-listen', 'click', function(e) {
    return console.log('hi');
  });

  $(document).delegate('.act-read.active', 'click', function(e) {
    $('.selected').children('.podcastDescription').toggle(500);
    return false;
  });

  $(document).delegate('.item-actions-read', 'click', function(e) {
    console.log('hi');
    return $(e.currentTarget).parent().parent().children('.podcastDescription').toggle(500);
  });

  $(document).delegate('.act-source.active', 'click', function(e) {
    return window.open($('.selected').attr('data-source'), '_newtab');
  });

  $(document).delegate('.act-download.active', 'click', function(e) {
    return window.open($('.selected').attr('data-file'), '_newtab');
  });

  $(document).delegate('.act-sorting', 'click', function(e) {
    return $('.act-sorting ul').toggle();
  });

  $(document).delegate('.sort-feed', 'click', function(e) {
    var feedSortMe;
    feedSortMe = [];
    $('.podcast-item').each(function(e) {
      var sortData;
      sortData = {
        uuid: $(this).attr('data-uuid'),
        feedTitle: $(this).attr('data-feed')
      };
      return feedSortMe.push(sortData);
    });
    if ($('.sort-feed').hasClass('descending') === !true) {
      feedSortMe.sort(function(a, b) {
        if (a['feedTitle'].toLowerCase() > b['feedTitle'].toLowerCase()) {
          return 1;
        } else if (a['feedTitle'].toLowerCase() < b['feedTitle'].toLowerCase()) {
          return -1;
        }
        return 0;
      });
      $('.sort-feed').addClass('descending');
      $('.sort-title i, .sort-date i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-feed i').removeClass('icon-chevron-up').addClass('icon-chevron-down');
    } else {
      feedSortMe.sort(function(a, b) {
        if (a['feedTitle'].toLowerCase() < b['feedTitle'].toLowerCase()) {
          return 1;
        } else if (a['feedTitle'].toLowerCase() > b['feedTitle'].toLowerCase()) {
          return -1;
        }
        return 0;
      });
      $('.sort-feed').removeClass('descending').addClass('ascending');
      $('.sort-title i, .sort-date i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-feed i').removeClass('icon-chevron-down').addClass('icon-chevron-up');
    }
    return $.each(feedSortMe, function() {
      return $('.podcastList').append($('[data-uuid="' + this.uuid + '"]'));
    });
  });

  $(document).delegate('.sort-title', 'click', function(e) {
    var feedSortMe;
    feedSortMe = [];
    $('.podcast-item').each(function(e) {
      var sortData;
      sortData = {
        uuid: $(this).attr('data-uuid'),
        podcastTitle: $(this).attr('data-title')
      };
      return feedSortMe.push(sortData);
    });
    if ($('.sort-title').hasClass('descending') === !true) {
      feedSortMe.sort(function(a, b) {
        if (a['podcastTitle'].toLowerCase() > b['podcastTitle'].toLowerCase()) {
          return 1;
        } else if (a['podcastTitle'].toLowerCase() < b['podcastTitle'].toLowerCase()) {
          return -1;
        }
        return 0;
      });
      $('.sort-title').addClass('descending');
      $('.sort-feed i, .sort-date i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-title i').removeClass('icon-chevron-up').addClass('icon-chevron-down');
    } else {
      feedSortMe.sort(function(a, b) {
        if (a['podcastTitle'].toLowerCase() < b['podcastTitle'].toLowerCase()) {
          return 1;
        } else if (a['podcastTitle'].toLowerCase() > b['podcastTitle'].toLowerCase()) {
          return -1;
        }
        return 0;
      });
      $('.sort-title').removeClass('descending').addClass('ascending');
      $('.sort-feed i, .sort-date i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-title i').removeClass('icon-chevron-down').addClass('icon-chevron-up');
    }
    return $.each(feedSortMe, function() {
      return $('.podcastList').append($('[data-uuid="' + this.uuid + '"]'));
    });
  });

  $(document).delegate('.sort-date', 'click', function(e) {
    var feedSortMe;
    feedSortMe = [];
    $('.podcast-item').each(function(e) {
      var sortData;
      sortData = {
        uuid: $(this).attr('data-uuid'),
        date: $(this).children('.podcast-feed').children('.moment').attr('data-date')
      };
      return feedSortMe.push(sortData);
    });
    if ($('.sort-date').hasClass('descending') === !true) {
      feedSortMe.sort(function(a, b) {
        if (moment(a['date']) < moment(b['date'])) {
          return 1;
        }
        if (moment(a['date']) > moment(b['date'])) {
          return -1;
        }
        return 0;
      });
      $('.sort-date').addClass('descending');
      $('.sort-title i, .sort-feed i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-date i').removeClass('icon-chevron-up').addClass('icon-chevron-down');
    } else {
      feedSortMe.sort(function(a, b) {
        if (moment(a['date']) > moment(b['date'])) {
          return 1;
        }
        if (moment(a['date']) < moment(b['date'])) {
          return -1;
        }
        return 0;
      });
      $('.sort-date').removeClass('descending').addClass('ascending');
      $('.sort-title i, .sort-feed i').removeClass('icon-chevron-down icon-chevron-up');
      $('.sort-date i').removeClass('icon-chevron-down').addClass('icon-chevron-up');
    }
    console.log(feedSortMe);
    return $.each(feedSortMe, function() {
      return $('.podcastList').append($('[data-uuid="' + this.uuid + '"]'));
    });
  });

}).call(this);
